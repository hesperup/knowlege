## 1.Get Started)

近几年随着微服务的流行，领域驱动设计(Domain-Driven Design) 重新回到了主流视野中。我自己最早是在大约 2003 ～ 2004 年左右了解到 DDD 的概念，之后一些金融行业的业务系统中尝试运用了 DDD 的理念进行系统设计，期间的确感受到了 DDD 与其他架构设计不同之处，但也遇到了不少问题。之后的几年中，我的工作内容逐渐转移到了互联网行业以及与数据相关的工作，在项目中也不太有机会使用 DDD。不过凑巧的是最近的一个项目中，我重新回到了我比较熟悉的金融核心系统研发的领域，而客户的需求之一就是使用 DDD 对核心遗留系统进行重构与拆分。在经过了 10 年之后，无论是技术还是业务都发生了不少的变化，而我自己对系统架构与设计也有了新的认识，重拾 DDD 这把扳手对我而言发生了有趣的化学变化，促使我对以前的一些概念与解决方案做了细致的梳理，也因此有了这个系列的文章。 我希望通过这个系列的文章不仅回顾 DDD 核心的知识与概念，还能够分享我在实际项目中遇到的问题与对应的解决方案。我比较认同的一个观点是架构师最大的工作是做出取舍，也就是在技术，业务价值之间找到 trade-off。所以我在项目中给出的方案不一定是最优的，也不一定适合你的项目，但是我会把「为什么」这样做告诉你，接着就是你怎么在自己的项目中进行取舍了。

## Why DDD

在开始详细分析 DDD 之前，我们先看一下 DDD 尝试解决什么样的问题。DDD 的相关文章与书籍中，被提及最频繁的关键字一定非「复杂性」莫属。对于复杂性的概念，我们先不展开讨论，把它的定义限定在所谓的「业务系统」的范围，那么「业务系统」又是个什么系统呢？说白了你可以认为就是个基于关系型数据库的 CRUD 系统

既然「业务系统」无非是对关系型数据库做 CRUD，那么复杂性体现在哪呢？我的答案是体现在繁琐的业务规则，以及未来不可知的业务变化。这么说你肯定觉得等于没说，所以我来举个栗子。很大概率你有过买保险的经历，不一定是你买，很可能是你父母为你购买保险，那么你购买保险在保险核心业务系统中是怎么实现的呢？

你想购买保险的这个行为称之为「投保」，而保险公司接受你「投保」请求，并出具保险单的行为称之为「承保」，简略描述从投保到承保的过程大致需要经历以下这些步骤。首先系统需要判断你投保的是个人保险，还是团体保险，这两个走的是两个截然不同的流程，这里我们只说个人保险的流程。对于个人保险，系统先要进行「核保」的流程，你可以认为是审核你有没有资格购买某项保险。而核保的规则一般分为基础规则与产品相关的规则。基础规则一般检查你的身份，国籍，年龄等信息，例如一定是本国公民，且已经成年等。而产品相关规则则是按照你需要购买的保险产品而定义的专有规则。

现在又提到了「保险产品」这个概念，保险产品按照不同的维度有不同的区分方式，例如按照保障期限划分，有极短期险，短期险，长期险和所谓的终身险。按照保障范围(国内一般称之为「责任」)，会分为医疗，意外，重疾，寿险等。还有些特殊的产品，例如万能，投连，年金等。这些产品的核保规则都是不同的，可能对于你现在的职业，年收入，健康状态都有不同的要求。

在通过核保之后，就需要按照你的个人状况计算费率，也就是你应该缴纳的保险费用。计算费率的过程也很有意思，一般分为表定法与公式法。顾名思义，公式法最好理解，就是由保险公司的精算部门定义一个费率公式，把变量带入之后计算即可。而表定法是通过一张称为「费率表」的东西来计算费率，具体计算逻辑我就不谈了，你只需要知道每种保险产品都有自己对应的费率表或是公式。

计算费率的过程中需要来自各方面的信息，例如被保人的年龄，职业类型，缴纳保费的方式(一次性缴清，或是分期缴纳，称之为趸缴与期缴)等等。计算出保费之后还需要计算代理人(就是介绍你买保单的那个人)佣金，这也是个非常冗长的流程。之后还有大段的流程，例如生成财务的收费记录，各种单证，打印记录等。

写到这我就不继续了，再写下去就变成保险系统的科普文了，但是你可以发现上述的流程有两个特点：

1. 涉及的节点非常多，且计算的逻辑牵涉到很多变量，且有很多的分支判断；
2. 牵涉到很多专业术语；

事实上我已经省略了很多业务规则，如果你被要求实现这样一个核心业务系统(承保只是保险核心业务系统中一个功能，一般属于「新契约」模块)，你该如何开始设计工作？以及怎么做设计工作？

DDD 的核心价值就是解决这类复杂系统的设计(至少它是这么宣称的)，如果你能理解并掌握 DDD 的话，在面对一个复杂的业务系统需求时应该能够给出一个合理，可行，具备可维护性与扩展性的设计方案。是不是很值得期待？那么我们继续往下看，DDD 是怎么做到这一点的。

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-85dbabda1ee88fc5a93d88ffdffe9ece_720w.jpg)

## 分层

「分层」是广大工程师最熟悉的架构模式之一，特别是对使用 Java 的 CRUD Boy 而言，分层架构是伴随着 Java EE 一路走来的。在 DDD 中也引入了分层的概念，只是与传统的三层架构不同，将中间我们一般称之为 Business Logic Layer 的那层分为了 Application 与 Domain 两层，如下图:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-65623aad775b64565c09d9ae9bcd7f46_720w.jpg)

对于分层 Eric Evans 的书中给出了一些说明，首先每一层只能依赖自己以下那一层的服务，而不能调用上一次的服务。可以理解为层与层之间的依赖关系是单向的，是自上而下的。其次 Application 与 Domain 是实现业务规则的核心，它们不应该依赖于某个特殊的框架或是技术，在 Java 中你的 Application 与 Domain 应该由 POJO 实现(Plain Old Java Object， 即普通的 Java 对象)。

Eric Evans 的书中给出了一些指导意见，但并没有给出相关的参考实现，那么问题就来了，项目中到底怎么实现分层？有的人会说这还有什么难的，不就是按照层级建几个 package 吗？其实问题的核心是如何管理层与层之间的交互。一些简陋的做法就是通过划分 VO(Value Object) ，PO(Persistent Object) 在几个层之间进行传递，但这远不是合理的分层架构实现。

我们先来看一个分层的参考实现，"The Clean “Architecture” 即整洁架构:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-4a08b19bc9fc8ec164393b0ecda5287e_720w.jpg)

当然还有其他类似的分层架构参考，例如「六边形架构」(Hexagonal Architecture)，「洋葱圈架构」(Onion Architecture) 等。接下来需要解决的就是如何在项目中实现这样一个分层架构了。

## 2. 实现分层架构

## 项目的目录结构

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-05e55143a477a3a8b615ec9b7703549d_720w.jpg)

上图是项目的第一层目录，分为 `application`，`domain`，`facade`，`infrastructure` 四个部分。接下来分别介绍这四个层的作用。

## Application Layer

`application` 对应了 DDD 中的「应用层」，同时也对应了 Clean Architecture 中的 Application Business Rule。从项目中的实践而言，它作为「粗粒度」业务的入口，也有人喜欢称之为一个 Use Case。在这一层中不应该包含复杂的业务规则，而是对下层的 `domain` (领域层)进行协调，对业务逻辑进行编排。需要注意的是这一层只应该依赖于下层的 `domain`层与 `infrastructure`层。

我们再看一下 `application` 内部是怎么划分的:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-b9e87566a883e5cdeb002d2c2d5743a9_720w.jpg)

`dto` 目录存放了的是 `application` 对上层暴露服务所接受的参数类型，也就是大家熟悉的 Data Transfer Object。`service` 目录则是之前提到的「粗粒度」的服务接口，这些服务需要做的就是按照业务逻辑将 `dto` 对象转化为 `domain` 层的领域对象，并调用相关领域对象的方法完成业务逻辑。如果需要还会调用 `infrastructure` 的服务。再次强调，这部分的服务不应该涉及到复杂，核心的业务逻辑。

## Domain Layer

`domain` 是 DDD 的核心层，具体的目录结构如下:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-ff40b9ed29121ce07660f2884bc2b2af_720w.jpg)

`domain` 之下的是名为 `bc1` 的目录，这里指代项目中某个业务的 Bounded Context(限界上下文)，关于 BC 的概念会在后续的文章中详细讲解。在 `bc1` 之下的才是详细的领域分层。

`exception` 目录中定义了领域层相关的异常，即一般称之为的 BusinessException，代表违反某些业务逻辑的异常，例如账户余额不足等。`model` 目录中定了领域对象，一般建议使用「充血模型」进行建模。`repository` 中定义了领域对象对应的「仓库」，关于 Repository 的概念也会在后续文章中专门讲解。`service` 则是定义了「领域服务」对象，如果认为 `model` 定义了业务模型，是名词，那么领域服务就是动词。

最后我们说一下 `event` 目录。在一个完整的领域模型中，我们往往需要划分多个不同的 Bounded Context，但是不同的 BC 之间应该怎么交互呢？ Eric Evans 的书中提供了集中不同的解决方案，例如自定义 DSL，防腐层等。而在我们具体的项目中，我们更倾向于使用基于「领域事件」的交互方式，这样不仅不会破坏各个 BC 间的封装，也移除了各自间的耦合。`producer` 中是事件的发送方，`handler` 是具体处理事件的对象。关于领域事件也会在后续专门介绍。

## Facade Layer

`facade` 是整个系统对外暴露服务的部分，具体目录结构如下:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-340743351bf7b52e58c9ae52834102fe_720w.jpg)

系统对外暴露两种协议的服务，即 RESTful 风格的 API 与 Web Service，对应的实现分别在 `rest` 与 `ws` 目录下。`facade` 层的工作是基于协议对客户端提供的数据进行校验，然后将数据转化为 `application` 层所需的 dto 对象，并调用 `application` 提供的服务。`facade` 中不应该有任何的业务规则与逻辑，只是完成数据对象的转换。

## Infrastructure Layer

`infrastructure` 层主要负责提供底层的纯技术服务，具体目录结构如下:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-1f86e1f847dd47c051498ea03a471341_720w.jpg)

这一层的功能都比较直白，是大家熟悉的具体技术实现，与领域模型没有任何的依赖关系，这里就不再赘述了。

## 问题与思考

以上是我们实际项目中结合 Clean Architecture 与 DDD 的分层实现，它的好处很明显，能够比传统的三层架构更好的兼顾领域层的隔离，整个的依赖关系也非常清晰明了，方便开发人员理解，所以我着重谈一些遇到的问题与思考。

### 繁琐的数据对象转换

从系统的分层架构来看，一共有三种类型的数据对象，分别为 DTO，Domain，PO(Persistence Object)。在实现一个业务功能时往往发生多次数据对象的转换，且大部分时间都是 getter 与 setter 的操作，非常的冗繁。

为了解决这个问题我们引入了 [Model Mapper](https://link.zhihu.com/?target=https%3A//github.com/modelmapper/modelmapper) 作为对象映射框架，省去了一些多余的代码。但是依然存在着另一个问题。考虑到 DDD 中的另一个概念: Aggregate(聚合)，当从 PO 转换为 Domain 时，需要以 eager 模式从存储中加载所有的数据，相对而言丧失了延迟加载的优化特性。

### 模糊的 Module 与 Bounded Context

在 DDD 理论中 Module 与 Bounded Context 是不同的东西，在上述的分层架构中，领域层有着明确的 BC 划分，但是在其他层却没有这些。最直接的现象就是随着系统功能的逐渐增加，业务规则日益复杂，`application` 目录下 `dto`，`service` 下的类会越来越多，由于缺乏进一层的抽象，导致后续的开发人员很难理解。

### 领域事件引入的事务问题

在引入领域事件之后，一部分的业务流程变为了异步调用，因此事务边界的管理变得更为复杂，在某些情况下无法达到事务一致性的要求。这无疑增加了开发者的心智负担，也提升了不少测试的难度。在这种情况需要进一步加深对业务的理解，尽量将事务特性从业务规则中移除或是绕开。

### 架构复杂性的提升

架构复杂性的提升带来的是开发人员学习的成本提升，在实践中，我们发现很多时候开发人员的代码中引入了错误的依赖关系，例如 `domain` 的方法签名中有来自于 `dto` 的对象，或是 `facade` 中引入了 `domain` 的领域对象。对于这种问题比较好的解决方案是加强 code review，加强开发人员对分层思想的理解，以及引入 [Unit test your Java architecture - ArchUnit](https://link.zhihu.com/?target=https%3A//www.archunit.org/) 这样的框架，在 CI 时对代码的依赖关系进行静态检查。

## 小结

本次介绍了项目中使用的 DDD 分层架构实现与遇到的问题，其实并没有一种完全正确或是适合任何项目的分层架构，掌握背后的思想与学会如何做出妥协才是一个架构师的工作。下一篇我会介绍项目中如何实现 Entity(实体)，Value Object(值对象) 与 Aggregate(聚合)。

# 3. Entity, Value Object

上一篇我们介绍了如何在CleanArchitecture与DDD的框架内划分一个项目的层级，而本篇文章中我们会聚焦在整个分层架构的核心部分，领域层中的关键概念:Entity(实体)，ValueObject(值对象)。

## Entity 与 Value Object

当采用面向对象的设计方法对系统进行建模时，我们需要做的是从业务需求中找到那些关键的「业务对象」，而这些业务对象也是 DDD 中 Entity 与 Value Object 的基础。我们先来看一下 Entity 与 Value Object 有什么区别。

Entity 应该是我们在日常分析过程中最熟悉的部分，它也是业务逻辑的核心体现。它应该具备以下的特性:

1. Entity应该具唯一的「标识」
2. 相比Entity所拥有的数据属性，我们更关注的是它的唯一「标识」

看一下我们的周围，我们的世界中充满了各种各样的 Entity。例如汽车就是一个 Entity，而它的唯一标识是「发动机编号」。iPhone 手机也是一个 Entity，「设备编号」则是它的唯一标识。需要注意的是在不同的业务场景中，**同一个** **Entity** **的唯一标识是可能发生变化的**，例如作为自然人，我们本身就是一个 Entity，在某些场景下，「身份证」就能作为我们的唯一标识。但是在另一些场景下则可能需要姓名，身份证，银行预留手机号这三个元素组成我们的唯一标识。

与之对应的 Value Object 顾名思义，关注的是数据，因为它并没有唯一标识，如果两个 Value Object 的数据都一样，那么我们可以认为这两个 Value Object 就是同一个对象。反观 Entity，差异就很明显，两个相同数据属性的 Entity 不一定是同一个对象，应该查看它们的唯一标识。例如有着相同姓名的「张三」两个人，就是完全不同的两个人，因为他们的身份证号码是完全不一样的。

项目中大家一定接触过 Code Table，也就是俗称的「码表」，例如存放性别类型的「男」，「女」等，这就是一个典型的 Value Object。

我们再来总结下 Value Object 具备的特性:

1. 没有唯一标识
2. 我们更加关注于它的数据属性

在此基础上我个人会再引申两个特性，具体的原因之后会详细说明:

- ValueObject不会「单独存在」，而是附属于某个Entity
- ValueObject的生命周期会与所附属的Entity绑定在一起

最后需要注意的是，**相同的对象在某个业务场景下是Entity，而在另一个场景下可能就是ValueObject了**，具体的例子我会在后面解释。

## 系统实现

了解了上述概念之后让我们看看如何在代码层面实现这两者。

有许多面向对象的设计理论可以用来指导我们发现业务需求中的 Entity，我觉得在前期不用太纠结于是否会遗漏某些 Entity，将专注点更多的集中在业务的核心流程上，特别是那些专业的业务术语。同时需要耐心分析的是 Entity 之间的关联关系，例如是 1 - N，还是 N - M。

结合 Eric Evans 书中的例子，我们分别看一下 Entity 与 Value Object 是怎样的。

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-1707d45c5c1fc99016fa27846da2b5cc_720w.jpg)

上图是汽车作为Entity的类图，可以很清楚的看到，汽车本身有许多的属性，例如颜色，座位数量，舵位(左舵车还是右舵车)，我们将「生产序列号」作为它的唯一标识。同时它关联的两个对象，一个为发动机，另一个则为轮胎。同样的，发动机也是一个Entity，它有着排量，生产日期等属性，而它的唯一标识则是发动机编号。不同的是汽车所关联的轮胎对象，它是一个ValueObject。汽车的例子中我们并不关心轮胎是否具有**业务的唯一性**，我们认为凡是具有相同品牌与尺寸的轮胎都是相同。接着让我们看一个轮胎作为Entity的例子。

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-515f284c08ed1fcb9af50fe2b85db7cd_720w.jpg)

假设我们正在处理一个更换轮胎的业务流程，那么我们就需要区分每条轮胎之间的差异了，因为汽车所使用的四条轮胎很可能具备相同的属性，但是在修理过程中更换为另一条轮胎，所以我们必须能够区分彼此的不同。如上图所示，轮胎的类中还是具有品牌与尺寸的属性，但是作为 Entity 多了一个生产编号作为它的唯一标识，而它也关联了另一个 Entity，即生产厂商。

如果你依然有些迷惑，我们直接看一下这两种对象模型在数据库中的展现形式:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-f540db5ba751158b334c420ac5643102_720w.jpg)

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-b65532587abb93d7934bc3f3df3d7431_720w.jpg)

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-af13fcd6b53fe36c43a3e12b063a817c_720w.jpg)

从数据库表结构的角度来看就很容易理解，Entity有着自己的业务主键(实际项目中我推荐使用逻辑主键)，而**ValueObject往往拥有一个指向所属Entity的外键，但是自己没有所谓的业务主键**。图三则是ValueObject的另一种映射方式，不用专门的表去映射一个ValueObject对象，而是用Entity对应表上的几个字段(Car表中tier开头的字段)。

## Persistence Object - 持久化对象

上面提到了 Entity 与 Value Object 在数据库中的表现形式，现在我们再向上看一层，在 Java 中他们的存在形式又是如何的呢？此时我们有两个选择，是否需要引入 Persistence Object 即持久化对象(PO)。

PO 的概念是从 Hibernate(JPA) 等 ORM 框架中产生的，PO 是由这些框架管理的，数据库表在面向对象中的映射。我们先来看如果引入 PO 之后的好处与问题，参考下图:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-024ff08bd8c81885847bb26000ecc0be_720w.jpg)

引入 PO 的好处在于将 Entity，Value Object 等对象与持久化框架解耦，只需要使用 POJO 就能实现 Entity，Value Object，而无需引入第三方的接口。事实上 Eric Evans 的书中也提及到 Domain 层的对象应该保持简单，不依赖于任何的第三方外部框架。同时它还带来了额外的灵活度，可以按照不同场景的需求从持久层读取数据后组装不同的领域对象。

这也会带来另一些问题，其一是我们需要额外编写一部分 Entity，Value Object 等领域层对象与 PO 的转换逻辑。其二是在进行领域层对象组装时，需要完整读取所有 PO 的数据，不能进行延迟加载的优化，某些业务场景下可能存在隐藏的性能问题。

第二种方式是使用 PO 实现 Entity 与 Value Object，这也是一般项目，或是 Hibernate，JPA 等推荐的方式。它带来的优点很明显，可以省去一层抽象，不用编写那些冗繁的数据对象转换代码。这种方式的限制同样明显，首先是领域层的对象会依赖于某个具体的持久化框架(需要增加特定的 annotation)，其次是在引入 Aggregate(聚合)后，不同业务场景，或是 Bounded Context(限界上下文)中，如果需要不同粒度的 Entity 映射相同数据库表时就会变的很麻烦，这个例子我会在介绍 Aggregate 时具体描述。

从项目实施的经验上来看，我更加建议分开 Entity，Value Object 与 PO 的关系，毕竟数据转换代码是可以通过框架减少很多，性能也是可以优化的，但是依赖关系在项目变得越来越庞大之后是没有那么容易解开的。

## 小结

我们介绍了DDD中Entity，ValueObject的概念与具体实现，下一篇会更加的深入介绍Entity的一种特殊形式，Aggregate(聚合)，以及Entity的整个生命周期的管理，Factory(工厂)与Repository(仓库)的概念与实现。

# 4. Aggregate — 聚合

上一篇中介绍了 DDD 中的核心概念，Entity 实体与 Value Object 值对象的概念，以及如何在项目中实现它们。而本篇文章我会介绍 DDD 中另一个核心概念，Aggregate 聚合。

## 什么是 Aggregate ？

其实 Aggregate 是一种模式，在代码中实现的具体形式很简单，分为两部分，首先是定义一个 Entity，作为 Aggregate Root，一般称之为聚合根。第二部分则是遵循 Aggregate 的完整性规则对领域数据进行操作。

在开始介绍具体的实现之前，我们先思考一下为什么要使用 Aggregate 这样的模式，它到底能为我们解决什么样的问题。

设想有这样一个业务场景，「客户增加保额」。从代码实现的角度来说，你可以这么做: 通过「保险单号」获取客户的保单信息，进而获取对应的保险产品信息，然后修改对应的「保额」，接着修改需要缴纳的「保费」，最后需要更新「被保险人」的信息。这样的需求实现起来其实不难，如果考虑使用 DDD 的方式，我们会设计 3 个不同的 Entity 对象，即保单(Policy)，保险产品(Product)，以及被保人(Insured)。然后类似的代码可能如同下面那样:

```text
policy.increaseInsuredAmount(xxxx);
product.changePremium(yyyy);
insured.updateBill();
```

这样的代码在功能上并没有什么不妥，但是从设计角度出发确是值得探讨的。从「客户增加保额」的实现来看，需要牵涉到多个 Entity 的数据更新，而上面代码的问题在于将这些数据更新的逻辑零散的暴露在代码中，当后续业务需求发生变化时，开发人员很难从代码上理解业务，从而造成遗漏与错误。

在设计方法或是 API 上，我们知道方法或是 API 的颗粒度不能太细，有时候需要设计一个粗粒度的方法，将实现的逻辑隐藏在这个方法之下，而不是暴露给客户端。当 Entity 的数据发生变化时，同样应该遵循这样的理念。在许多业务场景下，Entity 之间的数据都需要遵循一致性，在上面的示例中，当进行增加保额这项业务操作后，保单，产品，被保人这些 Entity 的数据状态应该是按照业务规则保持一致的，不应该出现保额增加，但是保费不变的情况。

那么 Aggregate 又是如何解决这个问题的呢？这就需要了解一下 Aggregate 的完整性规则了。

## Aggregate 的完整性规则

所谓的完整性规则又由下面两点组成:

- 所有的代码只能通过 Aggregate Root，即聚合根这个特殊的 Entity 访问系统的 Entity，而不能随便的操作任一的 Entity。
- 每个「事务」范围只能只能更新一个 Aggregate Root 及它所关联的 Entity 状态。

接下来让我们逐一解释这两项规则。

首先看第一条，这点很容易理解，单纯实现的话也很简单。参考之前的示例，我们可以把「保单」对象作为 Aggregate Root，而「产品」与「被保人」都作为这个 Aggregate Root 内部的成员变量。对外暴露的也只有「保单」对象上的方法。修改后的类图如下所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-6e539479d1689ff5d299dadb4de32a69_720w.jpg)

而代码也变为:

```
policy.increaseInsuredAmount(xxxx);
```

而 `policy` 的 `increaseInsuredAmount` 方法的内部实现则是:

```text
public void increaseInsuredAmount(BigDecimal insuredAmount) {
    this.product.changePremium(yyyy);
    this.insured.updateBill();
}
```

从代码中可以看到，我们不再逐个操作不同的 Entity 对象，而是只能通过 `policy` 对象完成整个业务逻辑，与业务规则相关的数据完整性则由作为 Aggregate Root 的 `policy` 对象保证。

在理解第一条规则的基础上，我们再来看一下第二条规则。第二条规则其实从字面意义上来说很好理解，就是在一个事务范围内，我们只能更新一个 Aggregate Root 以及和它相关的数据。为了简化问题，这里的事务特指是关系型数据库的事务。

但是这两条完整性规则会引出一些设计上的取舍，你必须在实际项目上想好如何解决这些设计问题。

## Aggregate 的设计

当需要实现 Aggregate 模式时，你需要解决的第一个问题就是找个一个合适的 Aggregate Root。在这个问题上无论是 Eric Evans 还是其他有关 DDD 的书籍都没有给出一个明确的答案，它们都举了一些例子，但是缺乏一个清晰的方法论来帮助架构师设计 Aggregate Root。书中的建议是「既不能太大，也不能太小」，这其实说了和没说一样。如果 Aggregate Root 设计的过大，那么无论实现什么业务规则都要拼装相同的 Aggregate Root 对象，必然有很对代码是冗余无用的。但是如果设计的很小，例如每个 Entity 都是一个 Aggregate Root，那么就很难做到每个事务只能更新一个 Aggregate Root 的要求。

我在项目上的经验是设计初期，尽量控制 Aggregate Root 的大小，不要关联过多的 Entity，造成出现「上帝类」这样的 Entity。当发现业务逻辑发生变化，需要更新额外的 Entity 状态时再丰富 Aggregate Root 的关联关系。如果项目中将 Domain 与 PO 分离，在设计 Aggregate Root 时的优势就很明显，不需要和持久层的关系型数据结构相耦合，能够在 Repository 进行自由的装配。

而另一种设计 Aggregate Root 的方法则是最近几年兴起的「事件风暴」，作为一种方法论，它可以帮助架构师与业务人员一起从业务流程中找到那些适合作为 Aggregate Root 的对象。具体如何使用「事件风暴」我会在之后的文章中讲解。

第二个在设计上需要考虑的是在分层架构的哪个部分定义事务范围。按照之前我介绍的分层架构，建议将事务控制放在 application service 那一层，与一个业务用例的粒度保持一致。

实际项目中「每次事务只能更新一个 Aggregate」的限制会比较严苛，因为当你将事务控制放在 application service 那层时也就意味着每个用例只能更新一个 Aggregate，在这种限制下需要设计一个合理的 Aggregate 就很难了，有时甚至是不可能的。如果一定要在一个事务内更新多个 Aggregate 该怎么办呢？一般我建议有两种选择。

### 领域事件 — 最终一致性

这种是 DDD 书籍上推荐的一种方式，使用领域事件的方式将单个 Aggregate 更新的事件广播出去，有其他对应的 hadler 收到后更新自己负责的 Aggregate。由于打破了事务一致性，因此需要某种机制来保证多个 Aggregate 的数据一致性。

使用这种解决方案的问题在于需要引入事务最终一致性的解决方案，这无疑会增加系统的复杂性。其次如果单纯为了满足单个事务与 Aggregate 的限制而脱离业务规则写了很多处理事件的 handler，那么无疑有点舍本逐末，为了 Aggregate 而 Aggregate 了。

### 打破规则

第二种并不能算是什么解决方案，实现起来很简单，就是打破每个事务只能更新 Aggregate 的限制，在 application service 中的单个事务中可以更新多个 Aggregate。

但是这也不是完全没有限制的，我们依然要遵循只能通过 Aggregate Root 引用 Entity 的规则，并且控制 application service 中能够访问 Aggregate Root 的数量，按照项目经验 3 个以下是可以接受的。

## 小结

Aggregate 是 DDD 中非常重要且特有的概念，它对外封装了 Entity 数据一致性，由此也是系统代码层面对业务规则的最直接的体现。而从 Aggregate 开始，业务知识在分析中的价值也逐渐开始体现。如何设计一个粒度合理的 Aggregate 需要丰富的业务知识与系统分析经验，而且随着业务的发展 Aggregate 也应该不断的重构。

# 5. Factory 与 Repository

之前的两篇文章中我们讨论了是领域的对象的核心概念，即什么是 Entity 实体与 Value Object 值对象。以及如何使用 Aggregate 聚合模式来封装 Entity，以保障它数据完整性。而本篇文章会讨论有关领域对象的最后一个部分，如何使用 Factory 工厂与 Repository 仓储模式来管理 Entity 的生命周期。

## 关于如何创建对象的思考

在 Java 语言中我们可以很容易的使用 `new` 关键字配合构造函数来创建一个对象。但是这样的做法比较简陋，容易存在一些潜在的问题。这也就是为什么在 Java 的经典著作 「Effective Java」中的开篇就建议大家尽量使用 Factory 工厂模式来创建对象，而不是直接使用 `new` 关键字。

对于领域对象亦是如此，一个领域对象应该由数据与方法组成，在领域对象被创建时，如何对数据做必要的初始化，以及 Entity 之间的关联关系都是值得思考的。

假设业务系统有个前端用来录入保险被保人的详细信息，而在后端负责处理业务的逻辑中需要将前端页面填写的数据存入关系型数据库中。按照之前文章中提及的架构，从前端的 HTTP 请求中获取相关的参数后需要在 `application` 那一层将数据转化为领域对象，一般是作为 Aggregate Root 的 Entity。

那么我们该如何创建一个新的 Entity 呢？当然使用 `new` 在功能上是可行的，但在实际项目中会有两个问题。

### 缺少封装

在 `application` 层中进行数据装配时会产生许多的重复代码。例如上述例子中初始化被保人信息时，需要将被保人作为一个 Aggregate，而它会关联保险产品，付费信息，联系方式等 Entity 或是 Value Object，如果每次在初始化被保人这个领域对象时，可能都需要写一堆的像下面这样的 getter / setter 方法:

```text
Insured insured = new Insured();
insured.setPolicyProduct(xxxxx);
insured.setBillingInfo(yyyyy);
insured.setContactAddress(zzzz);
```

更糟糕的是这种通过 getter / setter 方式初始化数据很容易造成开发人员的错漏。当一个对象结构较为复杂时，开发人员很容易遗忘调用某个 setter 方法而导致创建了一个数据不完整的 Aggregate。

可能稍好一点的方式是不用 getter / setter 方法，而是将这些关联对象作为构造函数的参数传进去，在构造函数中完成数据结构的装配。这从某种程度上解决部分的问题，但是它依然存在缺陷。

### 缺少业务语义

如同上面所说的，我们可以通过构造函数来保证 Aggregate 数据初始化的完整性。但是这种方法带来了第二个问题。想一下，在不同业务场景下 Aggregate 初始化所需要的参数可能是不同的，如果通过自定义构造函数的方式来控制数据初始化，那就需要定义多个参数不同的构造函数，即所谓函数重载(Overload)。例如这样:

```text
public class Insured {
    public Insured(PolicyProduct product) {
      ……
    }

    public Insured(PolicyProduct product, BillingInfo billingInfo, ContactAddress contactAddress) {
      ……
    }
}
```

上述两个构造函数有着不同的参数列表，应该在不同的业务场景中使用，但是因为方法名是相同，**无法表达业务含义**，因此开发人员还是无法确定到底应该使用哪一个都早函数进行数据初始化。

## Factory Pattern

为了解决这个问题，DDD 比较推荐的一种方式使用经典的 Factory Pattern(工厂模式)。工厂模式作为最简单的设计模式之一，被广大的开发人员所熟知，在 GOF 的书中，工厂模式也是第一个介绍的设计模式。简单来说，工厂模式通过一个特定方法，封装了对象数据初始化的逻辑。而这个方法其实就是个普通的方法，因此可以自由的定义方法名，而不必像构造函数那样受限，所以可以自由的表达业务含义。在项目中具体的实现方式也有两种选择，让我们依次来看一下。

### 由领域服务提供的 Factory Method

我们之前在分层架构中提到过**领域服务**的概念，如果说领域对象从某种程度上代表了领域知识中的**名词**，那么领域服务就对应了**动词**。我们可以在领域服务中定义所需要的方法来返回一个 Aggregate。

```text
public class PolicyIssueService {
    public Insured createInsuredFrom(PolicyProduct product, BillingInfo billingInfo, ContactAddress contactAddress) {
        ……
    }
}
```

上述的代码中我们定义了一个领域服务类，用来实现新保单承保的逻辑，其中的方法 `createInsured` 会返回一个 Insured 的实例，这就是我们定义的用来创建 Aggregate 的工厂方法。通过这样在领域服务中定义专门的方法，可以很好的封装领域对象的初始化逻辑，保证数据完整性的同时也不丢失业务含义。

### 由另一个 Aggregate 提供的 Factory Method

除了在领域服务上定义相关的工厂方法之外，在 Aggregate 上也能定义专门的方法来管理另一个 Aggregate 或是 Entity 的初始化。我们通过一个保险业务上的例子来说明这种情况。当被保人发生意外，如果在保险单的保障范围内，可以申请理赔。在申请理赔时需要录入许多事故相关和保险单相关的信息，因此可以将理赔申请设计为一个 Aggregate。而初始化这个 Aggregate 的方法可以交给另一个 Aggregate，即保险单的 Aggregate。具体代码可参考如下:

```text
//代表理赔申请的 Aggregate
public class ClaimApplication {
    ……
}

//代表保险单的 Aggregate
public class Policy {
    //创建 ClaimApplication 的工厂方法
    public ClaimApplication applyClaimWith(Accident accident) {
        ……
    }
}
```

上面的方法很好理解，在 `Policy` 上有个方法，`applyClaimWith`，它接受一个事故信息 `Accident` 对象，返回另一个 Aggregate `ClaimApplication` 。当采用这种解决方案时，我们需要更多的分析领域对象之间的关系，在合理的对象上定义工厂方法，切忌在一个 Aggregate 上定义过多的工厂方法，这样也就丢失了相关的领域知识。

## Repository Pattern

工厂模式能够帮助我们控制对象的初始化，这些对象创建之后还是处于内存之中，而作为一个业务系统不可避免的需要一种持久化的机制，能够将这些领域对象对应的数据存储起来，最常见的一种持久化机制就是关系型数据库。也由此我们可以看到，初始化对象数据来源并不仅仅来源于外部的输入，还可能来源于某种持久化机制。所以我们会引入领域对象生命周期的概念，参考如下的图片说明:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-a0b79c56cfb812a06dc741de09695e2b_720w.jpg)

一些开发者可能会把 Repository 与 DAO 混淆在一起，由于 Spring JPA 这样的框架在命名方面把两者交织在一起，更加容易加深大家的误解。Repository 从字面以上来看更加偏重业务的含义，作为一个「仓库」它所要做的是将领域对象重新拿出来，但是不必关心底层的细节。例如我们是使用一种关系型数据库，还是 NoSQL 数据库，作为领域层其实是不关心的，它们关心的是领域对象是否被正确的还原出来。而 DAO 在实际项目中往往会更底层些，它抽象的是不同关系型数据库的异同，你可以使用 MySQL，也可以使用 Oracle，但是对于 DAO 层暴露的接口应该是相同的。我们来看一个具体的例子。

```text
public interface InsuredRepository {
    public void save(Insured insured);
    public Insured findBy(Long id);
    ……
}

public interface ProductRepository {
    public void save(Product product);
    public Product findBy(Long id);
    ……
}
```

以上的代码中我们对两个领域对象，`Insured` 与 `Product` 定义了两个 `Repository` 接口，用以与某种存储机制进行交互。接下来看我们的实现。

```text
public abstract class InsuredDBDAO implements InsuredRepository {
    ……
}

public class MySQLInsuredDBDAO extends InsuredDBDAO {
    ……
}

public class MongoDBProductRepository implements ProductRepository {
    ……
}
```

我们使用关系型数据库存储 `Insured` 的数据，同时为了保证不耦合到特定的关系型数据库，我们定义了一个额外的 DAO 抽象类，然后提供了基于 MySQL 实现的具体类。而在 `Product` 这方面，我们更希望使用 MongoDB 这样一个 NoSQL 存储数据，因此我们直接使用了一个具体的类实现了 `ProductRepository` 的接口。但是这两个接口在领域层暴露的几口都是一致的，所以需要牢记的是 `Repository` 是属于领域层的，而具体存储机制的实现，无论是 `DAO` 还是其他的实现，都应该属于 `infrastructure` 层，属于具体的实现机制。

## 小结

这篇文章中我们谈论了领域对象生命周期的概念以及如何使用 Factory 与 Repository 模式来管理，封装领域对象。如何在一个业务规则复杂的系统中保证领域对象数据的完整性是非常重要但也是困难的，因此希望通过这次的文章你能从中获得一些启发。下次我们会讨论 DDD 中另一个很重要的概念，限界上下文和对应的代码实现，希望你不会错过。

# 6. Bounded Context - 限界上下文

之前的几篇文章中更多谈及的是有关具体代码层面的设计与实现，这在 DDD 中更多的被成为是「战术设计」，而接下来的几篇文章我会谈及 DDD 中设计的另一部分概念，更加偏向上层的「战略设计」。本篇会介绍「战略设计」的核心概念，Bounded Context，称之为限界上下文(之后简称为 BC)，以及在项目中如何实现。

## 什么是 BC？

如果你之前读过系列文章的第二篇，DDD 的分层设计，那么会发现其中已经谈及了 BC 的概念。这里会更加详细的解释一下。

设想一下，当一个业务系统逐渐复杂，愈发庞大之时，系统代码不仅应该在架构层次进行划分，以区分不同抽象层次以及功能。我们更应该从业务的角度出发，对系统进行某种维度的拆分。这种维度可能是按照不同的业务功能，也有可能是按照业务流程的不同阶段，根据系统的具体业务不一而同。

我们依然拿保险业务来作为参考。一般通用的业务按照不同的职能可以分为: 新契约(负责承保，可以简单的理解订立保险契约)，核保，保全，理赔，续期，产品，渠道，收付费等。在最初的设计中，这些都可以对应到一个独立的 BC。

看到这里你应该已经明白 BC 是什么了，它其实就是**系统内部按照不同业务目的进行划分的「模块」**。这里需要注意的是 BC 的划分更多是基于领域知识，它与技术的分层应该是正交的，两者之间互不影响。

既然你已经了解了什么是 BC，接下来就需要明确以下两个问题:

1. 如何设计 BC 的范围？
2. 如何实现 BC？

## 如何划分 BC？

这个问题其实很难回答，在我经历的项目中并没有一个非常成型的分析方法来帮助架构师分析找到系统中的不同 BC。造成这种情况的原因我觉得有以下几条。其一，我参与的都是金融行业的项目，而金融行业大部分的业务逻辑或是业务流程都是非常规范化的，因此不同客户之间的差异非常小，所以在划分 BC 时有大量的经验可以借鉴，除了在一些细节上需要按照客户的需求做一些变化，其他基本不需要做任何的改变。

其二就是软件架构往往受到「康威定理」的影响，即你的软件架构往往与组织部门的架构相一致。这其实很好理解，在许多系统中你会发现功能模块的划分是按照使用组织的部分而划分的。

综合以上两点，在很多项目中没有花必要的时间对领域知识进行深入的研究，而是通过一些不是那么合适的方法得到了一个所谓的「限界上下文」。上述两种方法最大的问题是对于领域知识没有进一步的分析，混淆了 **Operational Level(操作层)** 与 **Knowledge Level(知识层)** 的模型。在设计上只是将业务流程照搬到代码层面，而忽略了对于业务规则的模型与抽象。这也是为什么许多业务系统在需求不断增加之后无法有效的控制复杂度，最终导致整个系统代码的腐化，难以维护。

要解决这个问题，需要架构师有着丰富的行业知识或者需要一个有些系统分析经验的业务分析人员。因为 BC 的划分不仅需要系统分析与架构的知识，行业或者说是领域知识是同样重要的。但是如果你的团队中没有这样的人选，或者说你进入了一个完全陌生的行业，又该怎么做呢？此时一种可行的方法就是参考敏捷的实践，先划分一个粗略的 BC 模型，然后在每个迭代中细化，不断的明确每个领域对象的职责，提炼业务规则背后的模型。通过 code review 和迭代后的会议分析现有 BC 的合理性并加以修改。而这也需要类似 CI，单元测试等其他敏捷实践的支持，才能保证模型的不断演进。

## BC 的实现

在有了 BC 之后，如何在我们的代码中实现呢？同样的这也有几种不同的选择。先回顾一下我在第二篇文章中的图片，可以在图片中看到 BC 的结构:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-ff40b9ed29121ce07660f2884bc2b2af_720w-163722541778019.jpg)

如果你当前的项目是一个单体应用的话，通过 Java 语言提供的 package 机制是最简单的一种方法。如上图所示，在 `domain` package 下按照不同的 BC 划分不同的下层 package，在对应 bc 的package 下进行代码的编写。这种解决方案的优势在于简单易行，对于开发人员也非常容易理解，无非就是按照架构设计将不同的业务代码放到不同的业务模块之下。另一方面它的缺点也很明显，就是不同 BC 直接缺乏必要的隔离。

很容易想到不同 BC 之间是可能会发生交互的，举一个例子，无论是新契约，还是理赔，抑或是保全模块，都有可能产生财务费用，例如需要客户缴纳额外的费用，或是需要退费给客户。也由此需要与收付费的 BC 进行交互，调用相关的服务。针对这样的需求 DDD 同样提供了数个模式，而我比较建议且使用最对的还是 **Anticorruption Layer(防腐层) 模式**。「防腐层」对外提供了基于 Facade 模式的粗粒度接口，并通过 Adapter 将输入的数据适配为 BC 内部服务所需的数据对象。具体可参考下面的图片:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-006f3445eb65c598aded3b212e847313_720w.jpg)

在实际项目中仍然需要防止开发人员绕过「防腐层」直接调用另一个 BC 的代码。拿 Java 举例，在 Java9 之前，Java 在语言层面上提供的可见性封装无法限制开发人员的代码，因此需要额外的，类似 **ArchUnit** 这样的工具进行静态检查。如果项目使用的是 Java9 之后的版本，则可以通过 JigSaw 提供的 Module 特性进行进一步的封装。具体的方式就是将每个 BC 下的代码作为一个独立的 Jar 包进行构建，并在 `module-info.java` 中配置 BC 对外访问的可见性。

### BC 与微服务

单体应用的问题在于缺乏有效的架构解耦手段控制日趋增长的系统复杂度。可以预见的是当系统越来越庞大，BC 也越来越多，单个 BC 也越来越复杂时，系统的可维护性也会变得越来越差。此时可以考虑的另一种实现 BC 的手段就是将单体应用拆分为多个微服务。按照 BC 划分微服务的边界显的顺理成章，能够非常清晰的划分出每个微服务的功能边界。而在每个微服务的内部，可以根据 BC 功能的复杂程度再次拆分不同的 Sub BC。

同时在微服务的架构下可以将「防腐层」的功能放到 API Gateway 上，彻底的将一些数据转换和适配的工作从业务系统中剥离出去，具体的架构可以参考下图:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-196bc991855532d62fd957d26c8a41cd_720w.jpg)

微服务本身也是一个比较大的话题，之后会有专门的文章讨论。

## 不同 BC 中的领域对象

最后在设计 BC 时需要注意的是区分**具有相同名称的领域对象**在不同 BC 中的实现。思考一下，在「新契约」与「理赔」这两个不同的 BC 中，「保单」无疑都是核心的领域对象，但是在上述两个不同的 BC 中的侧重点，业务逻辑，数据属性都不同，因此可能领域对象的名称，或是对应 Java Class 的名称都成为 `Policy`，但这是两个截然不同的领域对象。

面对这种问题，一方面需要通过「统一语言」这一模式，在团队内部(不仅仅是研发团队，还应该包括业务分析团队和使用系统的业务部门)统一对于这两个不同领域对象的理解，避免歧义。而另一方面，更好的做法是给这两个领域对象各自起一个更为恰当的名称，例如 `IssuedPolicy` 与 `ClaimPolicy`，帮助团队加深理解。

## 小结

这次我们讨论了 DDD 中战略设计的核心概念 Bounded Context，以及如何在代码层面实现这一设计。在下一篇中我们会讨论 DDD 中其他一些常用的模式以及设计技巧，希望你不会错过。

# 番外篇: 事件风暴-概念

在我过往的项目经历中，DDD 落地遇到最大的问题会有两个，其一是如何发现系统中的 Aggregate(聚合)，其二是如何划分 Bounded Context(限界上下文)。这两个元素可谓是 DDD 的核心概念，分别对应了单个业务功能模块内核心的领域对象，以及如何划分业务功能的边界。

这两项工作的共同点，或者说是困难之处都来源于不是一项单纯的技术工作，而是掺杂了许多对于 Domain Knowledge 的理解。我自己并没有什么成型的方法论或是特定的模式来解决这一问题，可能唯一的建议就是多思考，多写代码，事后做好分析。同时作为开发者并不要排斥业务知识，而是应该多向业务部门的同事学习，了解他们对于系统的认知，以及行业的发展，这样才能真正的对系统设计有深入的思考。

然而最近的几个项目中，情况有了一些变化。在基于 DDD 进行系统分析方面有了一个新兴的方法论，即 Event Storming(事件风暴)，它是一种轻量级的系统分析方法，基于 DDD 的概念，能够为我们梳理系统中的各种相关元素，其中包括了核心的 Aggregate。这次的番外篇会介绍事件风暴的概念与使用方法，以及项目中遇到的问题与反思。

## 事件风暴

### 什么是事件风暴

事件风暴是由 Alberto Brandolini 发明的一种轻量级，基于 DDD 概念的系统分析方法，详细的解释可以参考它的官方网站: [Event Storming](https://link.zhihu.com/?target=https%3A//www.eventstorming.com/)。

在我有限的使用经验中，事件风暴最大的作用是帮助开发人员，业务人员，UX，测试等项目参与者对于业务流程有一个统一的认识，这包括关键的流程，核心的业务规则，系统不同模块的使用者。其次是帮助开发人员梳理核心的业务对象，从某种程度上来说就是就是领域对象中的聚合。

事件风暴都是以 Workshop 的形式展开，因此在开始之前需要做好各项的准备工作，下面介绍所需的前期准备。

### 准备工作

在开始事件风暴之前，需要邀请相关的参与人员，已经准备相关的物料，具体如下:

- **参加人员**: 条件许可的情况下应该全员参与，包括系统开发人员，业务分析师，业务人员，测试工程师，UX 设计师，项目管理人员等。

- **场地要求**: 场地尽可能的大，关键是要有一面长 4 米左右的墙壁，用来悬挂或是黏贴纸张。

- **其他物料**: 在进行事件风暴的过程中还需要准备以下的材料:

- - 马克笔，准备 3 种不同颜色的多只马克笔。
  - 数张大型的招贴纸，如果一时找不到很大的可以用几张小型的纸拼凑一下，具体效果参考下图:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-587a477d17296544b1032e646b98a7b4_720w.jpg)

- - 各种不同颜色的即时贴，包括**蓝色，黄色，红色，橙色，绿色，粉色，紫色**，不同颜色的即时贴对于事件风暴有不同的意义，因此请务必准备好这些颜色的即时贴。

### 核心概念

事件风暴将系统拆分为不同的元素，用不同颜色的即时贴表示，请参考下图对于不同颜色即时贴的解释:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-598146ae36fe32b6dc1fa4d6a098df69_720w.jpg)

- **事件(Event)**: 事件风暴中的核心概念，它代表了某一个**「业务行为」**，描述的形似为**宾语+动词的过去式**。例如: 「订单被提交」，「账户被锁定」，「商品已被发出」。使用**橙色**的即时贴表示。
- **命令(Command)**: 既然有了**事件**必然有产生事件的对象，这就是**命令**。命令可以理解为是一个动作，执行了动作之后就会产生相应的事件。典型的动作描述可以是: 「取消订单」，「结账」等。使用**深蓝色**的即时贴表示。
- **用户(User 或 Actor)**: 同样的**命令**也是由对象执行的，这称之为**用户**。这里的用户一般是指自然人，例如一个电子购物网站的顾客。

这里我们先做一个小小的总结，把上面的概念融合一下。

事件风暴的核心流程就是由**用户**执行了**命令**，从而产生了**事件**。基于这个**事件**的结果(后续会谈及)，与之前相同或是其他的**用户**会执行另一个**命令**，产生新类型的**事件**，以此类推。而顺序是按照业务逻辑而定的。简单的可以参考下面一个简单的示例:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-4717e8521478f0d26a50891ab16defc5_720w.jpg)

我们继续解释其他的概念。

- **规则(Policy)**: 当产生**事件**时，需要进行某些业务相关的**规则**校验，例如订单提交后需要检查库存是否充足，客户的支付交易是否成功等，诸如此类的业务规则可以使用**粉色**的即时贴表示。
- **读模型(Read Model) 与页面布局(Screen Layout)**: **事件**产生后的另一个结果往往是呈现在**用户**面前的系统界面，在这里我们使用**页面布局**进行展示。这部分的工作一般由 UX 与业务人员完成，展现他们所需要的用户界面。同时**页面布局**上会展现**用户**所关心的数据，例如，当**用户**执行「结账」的**命令**之后，生成了「购物车结算」**事件**，此时呈现在**用户**面前的应该是商品明细信息和总金额。这样的数据我们使用**读模型**表示。
- **外部系统(System)**: **事件**并不一定由**命令**产生，也可能由一个**外部系统产生**，例如一个第三方的支付系统会调用由你系统提供的回调接口，确认客户支付成功，由此产生一个「费用已支付」的**事件**。
- **问题(Question) 与假设(Assumption)**: 在讨论过程中各个参与人员可能会发生分歧，例如对于**事件**的定义，或是由哪个**用户**执行，或者是具体的**规则**是什么。此时如果无法在规定的 time box 之内达成统一意见(一般为 5 分钟)，可以将问题写在**红色**的即时贴上，作为**问题**，或是对某种情况的**假设**记录下来。
- **聚合(Aggregate)**: 当一个完整的业务流程通过上述方式写完之后，对于每个**用户，命令，事件**进行组合，我们就能获得**聚合**了，用事件风暴的描述就是「用户在 XX 聚合对象上执行了 YY 命令，生成了 ZZ 事件」。例如「顾客在购物车对象上执行了结账命令，生成了购物车结算事件」。即时贴的效果如下图:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-c98e3a06ee99393683f9c44f91be4d08_720w.jpg)

最终效果如下图所示，你将获得完整的业务流程分析:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-e71daeee5bc8e50eb47c74220bd7d8cc_720w.jpg)

## 小结

由于篇幅所限，这次只是简单介绍了事件风暴的概念，和简单的使用介绍。下一篇中我会通过一个具体的业务场景描述如何使用事件风暴进行完整的业务分析，并识别出领域中的聚合对象等核心元素。

# 番外篇: 事件风暴-实践

::上一篇:: 文章中介绍了什么是事件风暴，以及相关的概念。那么这次会通过一个实际的例子带领大家经历一次完整的事件风暴，并且分享自己在使用事件风暴中所遇到的问题。那么就让我们开始吧。

## **背景**

在正式开始事件风暴之前，先来介绍一下业务分析的场景。我从之前参与保险核心业务系统中选择了一个业务场景，用来展现如何使用事件风暴发现领域中的聚合与其他相关领域对象。

这里选择的业务场景是保险事故的理赔流程，由于篇幅的问题，我省略了一些过于琐碎的业务细节，保留了主干流程与核心的业务规则，以下是对业务流程的介绍。

### **理赔受理**

理赔受理主要涉及由保单投保人向保险公司提出理赔申请，并由理赔受理人员按照提交的事故信息在系统中进行录入，并进行必要的业务规则校验，例如当前投保人是否持有有效的保单，事故类型是否在保单保障的范围之内等。

如果这些业务校验都通过，那么就会生成一条崭新的理赔申请。

### **理赔审核**

审核部分的工作则主要分为两个部分，其一是对受理阶段录入的事故与保单信息进行复核，检查是否存在错误或是欺诈。其二是在保险产品基础理赔金额的基础上进行手动的修改。

如果在审核过程中发现任何问题，可以将该次理赔申请退回至受理的阶段，重新填写相关信息。而如果当前理赔信息正确无误，则进入下一个业务环节。

### **理赔给付**

这部分的工作主要是对理赔的最终金额和其他相关信息进行确认，如果确认无误则会产生需要支付费用的财务信息，否则该理赔申请会退回审核的环节。

以上就是经过缩减的保险理赔流程，接着看看事件风暴是如何帮助我们对业务流程以及领域对象进行分析的。

## **事件风暴**

### **受理事件**

经过业务人员的叙述后，我们得到了如下的「命令」与「事件」。

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-dca32001669a634517a947d37d848b8a_720w.jpg)

从图中我们可以看到「理赔受理员」作为用户发起了「提交理赔申请」命令，而该命令生成了「理赔事件已提交」的事件。

紧接着我们与业务人员继续深入讨论，了解到在提交理赔申请时需要进行相关的业务规则校验，如下所示:

```text
* 理赔申请中填写的事故人是系统中已有且有效的被保人
* 事故发生的时间在保单生效的时间范围之内
* 事故的类型是保单保障范围内的
* 如果理赔受理申请成功，则进入理赔审核环节
```

为了叙述简单，省略其他相对繁琐的业务规则，只保留了以上这些作为示例。按照上面由业务人员讲述的业务规则之后，我们可以在事件风暴上增加「规则」的部分，如下图所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-874ee8c18938b1376268082fc0795efc_720w.jpg)

然后业务人员会向我们描述在理赔受理过程中需要提交的各种数据项，例如投保人，事故人的详细信息，包括姓名，年龄，证件号码等。以及相关事故的信息，包括事故类型，发生时间等。同时我们还了解到，在进行理赔受理的时候需要给受理人员实时展示符合条件的保单列表，供受理人员进行选择。

按照以上这些信息，我们可以提炼出多个「读模型」，用来展示用户所需的数据，此时的事件风暴如下图所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-0fd3af31b63afb70cf905e505f103431_720w.jpg)

而在「读模型」的基础上，可以设计用户界面的草图，让整个团队在 UI 层面达成一致。修改后的事件风暴如下所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-56058bf17a81b9c8f6c18d51cae241a8_720w.jpg)

现在我们已经使用事件风暴的方式对理赔受理做了一个初步的建模，现在可以试着分析理赔受理环节所牵涉到的聚合与领域对象。从「命令」与「事件」的名称中我们其实很容易就看到「聚合」的线索，即名为「理赔申请」的聚合对象。接着就要分析这个聚合对象有哪些领域对象组成。

「规则」与「读模型」为我们展示了更多「理赔申请」的所需信息，包括「投保人」，「被保人」，「事故」，「保单」这些领域实体，也有「事故类型」，「保障范围」这些值对象。通过对这些信息的梳理，可以得到一个聚合的草图，如下图所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-667ee5b66df7111df305ffef248456da_720w.jpg)

我们可以把它贴在「命令」与「事件」的中间，并做一些修改如下图所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-6ac70b9d2434ccc0bcac26fa3e5e4f49_720w.jpg)

### **审核事件**

从受理的业务规则中我们得知，如果理赔受理成功，那么该次的理赔申请就会进行后续的审核与理算。因此接着是由理赔审核人员审核该次理赔申请，并理算相关的赔付金额。审核的业务流程是由受理对应的业务规则所产生，因此从图上可以看到，该「命令」的发起者不再是「用户」，而是「规则」，如下图所示:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-603d6103cb8d88038db452b8d3e5f097_720w.jpg)

参照之前受理的分析过程，我们可以将与事件相关的规则，读模型，等元素逐一增加上去。最终完成理赔审核流程的分析。

### **其他需要注意的问题**

在实际的分析过程中，有些场景中「命令」并不是通过作用在「聚合」上之后再生成「事件」的，而是作用在一个「外部系统」上，在事件风暴中可以通过一个粉色的便签表示「外部系统」。

还有就是如果在事件风暴进行过程中发现任何问题，不应该陷入长时间的讨论，可以设定一个简单的 time box，例如 5 分钟。如果在时间范围内没有达成共识，可以用一张红色的便签标注这个问题，留待之后进行专项的讨论。

最后一点是可以通过事件风暴来划分系统内的限界上下文，主要的方法是寻找连接不同业务模块的关键事件。

## **对于事件风暴的一些思考**

在使用了几次事件风暴之后，我也对这种方法论有了一些相对深入的思考。我们先不妨看一下，事件风暴完成后的交付是什么？最显著的成果当然是来自于领域模型的「聚合」。但是依照我的经验，这里的聚合更多的是**「概念层面的模型」**，并不适合直接拿来做数据模型甚至是代码层面的设计。由于进行事件风暴的事件长度一般为 2～3 小时，因此不可能牵涉到太多的业务细节，所以这里得到的聚合模型更多的价值在于帮助开发人员挖掘领域实体的概念，澄清各个领域实体之间的关系。对于业务人员而言，事件风暴的价值在于将开发系统所需的领域知识通过一种简单，清晰，且整个团队都理解的方式呈现出来。所以事件风暴另一项我觉得非常有价值的作用就是**「统一语言」**，帮助整个团队对于领域知识，领域对象以及之间的关系达成一致。

那么有了事件风暴梳理的业务流程，是否还需要需求文档呢？我的答案是需要，而且应该在事件风暴开始之前就准备好，至少是个初版。在事件风暴的过程中需要讨论大量的业务规则，但是不可能在有限的时间内，在现场将这些规则一一罗列，特别是牵涉到大量的业务数据项。因此在开始之前，业务部门应该首先梳理一个大致的业务流程与相关的业务规则，避免在现场再开始回忆，从而消耗时间，并且可能遗漏重要的业务规则。

不必纠结于在事件风暴的现场需要列出所有的业务规则与流程，这是不现实也是不可能的。就如我之前提到的，事件风暴带给团队更多的是对于领域知识认知的一致性，以及对于概念模型的认知。在此基础上需要更进一步的分析与设计工作才能落实到具体的代码，注意不遗漏关键的主线流程和核心的业务规则即可，可以在事件风暴结束前做一个总体性的回顾，看看有没有疏漏之处即可。

最有一点就是**「没有银弹」**，不应该寄希望于某种方法论一锤定音，能够得到完美的系统架构和领域模型。提升团队整体对于领域知识的理解与共识，提高自身的设计能力，避免系统的强耦合，快速短小的迭代才是实践领域驱动设计的不二法门。

# DDD 中的那些模式 — CQRS

DDD 作为一种系统分析的方法论，最大的问题是如何在项目中实践。而在实践过程中必然会面临许多的问题，「模式」是系统架构领域中一种常见的手段，能够帮助开发人员与架构师在遭遇某种较为棘手，或是陌生的问题时，参考已有的成熟经验与解决方案，从而优雅的解决自己项目中的问题。

从本期开始，我会开始介绍 DDD 中一些常见的模式，包括这些模式的背景，作用，优缺点，以及在使用过程中需要注意的地方。而本次的主角就是 CQRS，中文名为命令查询职责分离。

## **为何要使用？**

毋庸置疑「领域」在 DDD 中占据了核心的地位，DDD 通过领域对象之间的交互实现业务逻辑与流程，并通过分层的方式将业务逻辑剥离出来，单独进行维护，从而控制业务本身的复杂度。

但是作为一个业务系统，「查询」的相关功能也是不可或缺的。在实现各式各样的查询功能时，往往会发现很难用领域模型来实现。假设在用户需要一个订单相关信息的查询功能，展现的是查询结果的列表。列表中的数据来自于「订单」，「商品」，「品类」，「送货地址」等多个领域对象中的某几个字段。这样的场景如果还是通过领域对象来封装就显的很麻烦，其次与领域知识也没有太紧密的关系。

此时 CQRS 作为一种模式可以很好的解决以上的问题，那么具体什么是 CQRS 呢？又如何实现呢？

## **什么是 CQRS？**

CQRS — Command Query Responsibility Segregation，故名思义是将 command 与 query 分离的一种模式。query 很好理解，就是我们之前提到的「查询」，那么 command 即命令又是什么呢？

CQRS 将系统中的操作分为两类，即「命令」(Command) 与「查询」(Query)。命令则是对会引起数据发生变化操作的总称，即我们常说的新增，更新，删除这些操作，都是命令。而查询则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查找数据。

CQRS 的核心思想是将这两类不同的操作进行分离，然后在两个独立的「服务」中实现。这里的「服务」一般是指两个独立部署的应用。在某些特殊情况下，也可以部署在同一个应用内的不同接口上。

Command 与 Query 对应的数据源也应该是互相独立的，即更新操作在一个数据源，而查询操作在另一个数据源上。看到这里，你可能想到一个问题，既然数据源进行了分离，如何做到数据之间的同步呢？让我们接着往下看。

## **实现 CQRS**

让我们先看一下 CQRS 的架构图:

![img](C:/Users/RMD-JX/Documents/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/DDD%E6%A1%88%E4%BE%8B/Untitled.assets/v2-da8a89f95e09bb518ad8c770b1413e5e_720w.jpg)

从图上可以看到，当 command 系统完成数据更新的操作后，会通过「领域事件」的方式通知 query 系统。query 系统在接受到事件之后更新自己的数据源。所有的查询操作都通过 query 系统暴露的接口完成。

从架构图上来看，CQRS 的实现似乎并不难，许多开发者觉得无非是「增删改」一套系统一个数据库，「查询」一个系统一个数据库而已，有点类似「读写分离」，并没有什么特别的地方。但是真正要使用 CQRS 是有许多问题与细节要解决的。

## **CQRS 带来的问题**

### **事务**

其实仔细的思考一下，你应该很快会发现 CQRS 需要面临的一个最大的问题: 事务。在原本单一进程，单一数据源的系统中，依靠关系型数据库的事务特性能够很好的保证数据的完整性。但是在 CQRS 中这一切都发生了变化。

当 command 端完成数据更新后，需要通过事件的形式通知 query 端系统，这就存在着一定的时间差，如果你的业务对于数据完整的实时性非常高，那么可能 CQRS 不一定适合你。

其次一个 command 触发的事件在 query 端可能需要更新数个数据模型，而这也是有可能失败的。一旦更新失败那么数据就会长时间的处于不一致状态，需要外部的介入。这也是在使用 CQRS 之前就需要考虑的。

从事务的角度来看 CQRS，你需要面对的是问题从根本来说是个最终一致性的问题，所以如果你的团队在这块没有太多经验的话，那么需要提前学习并积累一定的经验。

### **基础设施与技术能力的挑战**

CQRS的另一个问题是没有一个成熟易用的框架，Axon 可能算一个，但是 Axon 本身是一个重量级且依赖性较高的框架。为了 CQRS 而引入 Axon 有点舍本逐末的意思，因此大部分时间你不得不自己动手实现 CQRS。

一个成熟可靠的 CQRS 系统对于基础设施有一定的要求，例如为了实现领域事件，一个可靠的消息中间件是不可或缺的。不然频繁丢失事件造成数据不一致的情况会让运维人员焦头烂额。之前提到的分布式事务与最终一致性的问题也需要专门的中间件或是框架的支持，这些不仅仅提升了对基础设施的要求，对于开发，运维也提出了更高的要求。

开发过程中需要加入对于事件的支持，系统设计的思路也同样需要一定的转变。在定义 command 时需要设计对应的事件，设计事件的类型与数据结构，所以在这方面也对开发团队提出了新的要求。

因此在开始使用 CQRS 之前不妨对自己团队的基础设施以及开发能力做一次全面的评估，尽早的识别出短板，并进行有目的的改进与强化，避免在开发过程中别某些问题卡住。

### **查询模型的设计**

虽然 CQRS 为我们分离了领域模型和服务于查询功能的数据模型，但这意味着我们需要设计另一套针对查询功能的数据模型。一般比较简单的做法是按照查询功能所需的数据进行设计，即针对每一个查询接口设计一个数据视图，当收到领域事件时更新有关联的数据视图。

但是这种简单做法带来的问题就是当查询接口越来越多时就会难以管理，仍然需要按照 DDD 中划分 BC 的思路将属于一个 BC 的查询集中管理作为整个查询系统的一个上下文，或是干脆独立出来做一个微服务。所以即使引入了 CQRS，我们依然需要使用领域驱动的思路设计查询接口。

### **与 Event Sourcing 的关系**

[Event Sourcing](https://link.zhihu.com/?target=https%3A//martinfowler.com/eaaDev/EventSourcing.html)是由 Martin Fowler 提出的一个企业架构模式。简单的来说它会将系统所有产生业务行为以 append-only 的形式存储起来，通俗的说就是「流水账」。它的优点是可以「回溯」，因为记录了每一次数据变动的信息，所以当出现 bug 或是需要排查业务数据问题时就非常的方便。但是它的缺点同样明显，就是当需要查询最新状态的数据时需要做大量的计算，例如账户余额这样的数据。

许多讨论 CQRS 的文章中都会谈及 Event Sourcing，认为这是两个需要配套使用的模式。但是从我实际使用的角度而言，这两个模式其实并没有什么必然的联系。Command 端只需要关心领域模型的更新成功与否，同时使用 Aggregate 这样的领域对象保证数据的完整性，而 Query 端关心的是接收到领域事件后更新对应的数据模型，对于「回溯」这样的特性并没有强制的要求。的确 Event Sourcing 可以帮助我们构建更为稳定，功能更为强大的 CQRS 系统，但是 Event Sourcing 本身的复杂性可能比 CQRS 有过之而无不及，所以在没有特殊需要的情况下，CQRS 与 Event Sourcing 不需要绑在一起。

### **不同类型的数据存储引擎**

这一点其实不能算是问题，更多的是一项挑战或是优势。由于分离了领域模型与数据模型，因此意味着我们可以在 Query 端使用与查询需求更为贴近的数据存储引擎，例如 NoSQL，ElasticSearch 等。

比较常见的情况是 Command 端依然使用传统的关系型数据库，但是对于那些比较特殊的查询则使用专门的数据存储。例如在一些基于关键字进行全文检索的场景，如果依然使用关系型数据库，通过 like 这样的 SQL 查询，很容易遇到性能问题。此时则可以将数据存储换为 ElasticSearch 这样的检索引擎，通过反向索引提取关键字查询，在性能方面会得到非常明显的提升。在另一些需要非结构化数据查询的场景，Json 是一种不错的存储格式，虽然现在比较新版本的关系型数据库都提供了 Json 格式的存储与查询，但是 MongoDB 这样的文档型数据库显得更为简单高效，此时 Query 端灵活的优势就更为明显。

## **小结**

CQRS 在 DDD 中是一种常常被提及的模式，它的用途在于将领域模型与查询功能进行分离，让一些复杂的查询摆脱领域模型的限制，以更为简单的 DTO 形式展现查询结果。同时分离了不同的数据存储结构，让开发者按照查询的功能与要求更加自由的选择数据存储引擎。

同样的，CQRS 在带来架构自由与便利的同时也不可避免的引入了额外的复杂性与技能要求，例如对于分布式事务，消息中间件的管理，数据模型的设计等等，所以在引入 CQRS 之前需要对团队能力与现有架构做仔细的分析，对短板进行必要的提升。如果现有系统逻辑较为简单，只是一些 CRUD，那么并不建议使用 CQRS。但是如果你的业务系统已经非常庞大，业务流程庞杂，逻辑繁琐，那么不妨尝试使用 CQRS 将 Command 与 Query 进行拆分，将领域模型与数据模型的边界划分的更清晰些。

# DDD 中的那些模式 — 使用 Specification 管理业务规则

许多开发者在项目中希望能够使用 DDD 原因在于能够管理业务的复杂度，避免在业务规则愈发复杂的情况下代码以及架构发生腐化，最终变的难以维护。系统复杂度体现在多个层面，例如繁琐的流程，繁复的校验规则，数据的多样性等，DDD 对于不同层面的复杂度提供了不同的应对模式，今天的文章会聚焦与如何使用 Specification 模式解决「业务规则」相关的复杂性。

## **业务规则**

在介绍 Specification 模式之前，我们先明确一下什么是「业务规则」。作为一个开发者，以下的这些一定是你日常工作中常见的工作。

- 校验业务对象的某些状态是否合法，例如当前账户是否启用，账户余额是否充足，事故日期是否在保险单的有效时间内。
- 从业务对象的集合中筛选出符合条件的结果集，例如从用户的交易记录中找出购买打折产品的记录。
- 检查一个新创建的业务对象是否符合某些业务条件，例如一张新创建的订单，它对应的客户与商户都应该是合法系统用户。

为了方便后续的讨论，我们将业务规则的概念窄化为以上三种类型。接下来的问题是这些业务规则在系统中是如何实现的？

最原始的方法是编写了许多小方法实现这些校验或是筛选逻辑，分散在各个 Domain Service 类中。这样做的缺点很明显，其一是难以管理，当业务规则越来越多时，这些散落在各处的方法就无法复用，而开发人员也没有办法集中的管理这些方法。其二是丢失了业务知识，这些方法大部分都很短小，简单，但是这些规则其实包含了大量的业务知识，如果任其分散在不同的 Domain Service 中，后续的开发过程中就很容易丢失这些业务知识。

在此基础上的另一个方案也是实际项目中使用比较多的，即编写各种不同的 Validator 类，每个 Validator 类中有大量对于领域对象的校验方法。这种做法一定程度上解决了第一个问题，通过特定的类将检验方法集中起来，可以方便开发人员进行维护和扩展。下面是一个典型的 Validator 的示例代码:

```text
public class CustomerValidator {
    public static boolean isVIP(Customer customer) {
        ……
    }
}
```

但是这对于业务知识的传递揖让没有太大的帮助。Validator 类更像是一些工具类，和领域层并没有什么关联。而当需要对这些校验方式进行复用时，特别是将几个校验规则按照 `and`， `or` 这样的逻辑关系组合起来时，Validator 就支持不是那么好了。

另一种方法是是将这些校验的规则在领域对象中实现，作为该领域对象的一个方法。参考如下的代码:

```text
public class Customer {
    public boolean isVIP() {
        ……
    }
}
```

这总做法优点是校验规则与领域对象结合的非常紧密，开发人员一看就明白。但是缺点同样明显，就是你的领域对象会变得日益臃肿，充斥着大量类似这种的校验方法掩盖了核心的业务规则。

那么有没有更好些的做法呢？Specification 模式提供了一种不错的选择。

## **Specification 模式**

DDD 中认为这些规则都是纯粹的「动词」，因此需要单独的建立模型，而这些模型都应该是简单的「值对象」。一个 Specification 接口示例如下:

```text
public interface Specification<T> {
    boolean isMatch(T domainObject);
}
```

然后我们可以实现是否 VIP 客户的校验:

```text
public class VIPCustomerSpecification<Customer> {
    @Override
    public boolean isMatch(Customer customer) {
        ……
    }
}
```

通过实现 `Specification` 接口，我们可以对不同的领域对象扩展不同的校验逻辑，而这些类都是可以复用的。同时这些 `Specification` 可以作为基础元素进行任意的组合，组合更为复杂的校验规则与筛选逻辑。例如下面的例子中，我们将所有更上层的领域逻辑封装在 `CustomerSpecifications` 中，而它可以通过组合各个单独的 `Specification` 提供具体的功能。

```text
public class CustomerSpecification {
    public boolean isSpecialCustomer(List<Specification<Customer>> specifications, Customer customer) {
        ……
    }
 }
```

在上面的 `isSpecialCustomer` 的方法中可以传入校验所需的一系列 `Specification`，并依次校验，这种做法也便于扩展与复用，与领域模型结合的更为紧密。

### **使用 Specification 模式过滤数据**

从一个数据集中筛选出符合条件的结果也是日常开发中常常需要实现的业务规则。那么我们一般的做法是如何的呢？

假设我们需要筛选出某个客户名下在一月到二月的订单记录，一种最简单也是最常见的做法就是通过 SQL(假设这些数据都是存放在关系型数据库中)。例如通过如下的 SQL 查询:

```text
select * from t_order where t_order.customer_id = ? and t_order.created_at >= ? and t_order.created_at <= ?
```

使用 SQL 在查询中直接实现筛选逻辑看起来很自然，但问题是这部分的逻辑本来应该是属于领域层的，现在却泄漏到了数据层，造成的后果就是维护的难度大大提升，很多业务系统到后期都是在和大段大段的 SQL 做斗争，而应该编写逻辑的 Service 层，Domain 层都成了摆设，退化成了纯粹的数据对象，传来传去，与 DTO 没什么差别。而 Specification 模式可以提供一种不错的解决思路。

我们可以在有如下的代码:

```text
public class OrderSpecifications {
    public Specification<Order> inPeriod(LocalDateTime beginTime, LocalDateTime endTime) {
        ……
    }
}
```

在这里 `OrderSpecifications` 并没有直接进行数据筛选，而是通过输入参数创建了一个特有的 `Specification` 对象，然后由 `OrderRepository` 对象接受 `Specification` 为参数进行真正的数据筛选操作。这样就将查询与过滤的逻辑分开了。

此时需要考虑的问题是性能，如果按照 SQL 的做法，那么在数据库端就会完成数据的查询与过滤，返回给应用端的数据量不会很大，但是如果使用 Specification 模式那么，就是在内存中进行过滤了，在数据量大的情况下必然会遭遇性能的问题。之前在项目中的确也遇到过类似的问题，由于查询结果数据量过大，而且需要分页展示，这些都在内存中完成的化，并发量一大内存的占用量以及响应速度都变得非常差。

解决的办法有两种，一种如 DDD 书上所介绍，在 `Specification` 接口上提供一个类似 `asSQL()` 的方法，将当前的 Specification 对象转化为 SQL 语句。在我一些项目的实践中这种做法比较麻烦，可以认为是换了一种方式拼接 SQL，效果并不好，且难以处理。而另一种则是使用 ORM 框架或是其他高级框架的能力。例如 [Spring Data JPA](https://link.zhihu.com/?target=https%3A//docs.spring.io/spring-data/jpa/docs/2.2.6.RELEASE/reference/html/%23specifications) 就提供了基于 JPA 的 Specification 模式的查询功能，使用起来非常方便，也是我建议大家在项目中可以尝试的方式。

## **小结**

Specification 模式是一种非常实用的模式，能够很方便的帮助开发人员对状态校验，数据筛选这样的业务规则进行管理与抽象，而且实际操作的难度较低，对外部的依赖也少，是个十分值得推荐的 DDD 最佳实践。

# DDD 中的那些模式 — 领域事件

严格的说事件驱动并不是一种模式，应该是一种架构风格或者编程范式。但是领域驱动设计中事件驱动所涵盖的范围没有那么大，往往只是作为整个系统解决方案的一部分，所以我还是把它归类在模式的范畴内。

事件无论对业务人员还是开发者都是非常熟悉且容易理解的概念，因此无论是在日常的需求沟通，还是系统设计中，事件都是建立领域模型时非常有用的工具。而在「事件风暴」这样的分析方法中，「领域事件」更是不可或缺的元素。在继续介绍领域驱动设计中的事件之前，我们先了解一下为什么要使用「事件」模式。

## **为什么需要「领域事件」**

在之前介绍 Aggregation 聚合的文章中曾谈及，Aggregation 一个显著的特点或是限制条件就是每个事务应该只更新一个 Aggregation。无疑这对于系统设计提出了不小的挑战，如何设计一个粒度适中，又能符合业务要求的 Aggregation 并不是一件容易的事情。但是领域事件为我们提供了一种更为优雅的解决方案，在 Aggregation 完成更新后产生一个新的事件并广播出去，由其他订阅该事件的订阅者完成其他 Aggregation 的更新。这样就解除了 Aggregation 之间的耦合。

而另一个能让领域事件大显身手的地方是不同限界上下文之间的交互。现在较为流行的架构风格是将不同的限界上下文作为不同的微服务，微服务之间通过 API 的形式交互。但是 API 并不是唯一的解决方案，在某些场景下基于消息中间件的事件模型能够更好的降低耦合，提升系统的弹性。

## **如何使用「领域事件」**

虽然事件的概念对于开发人员很好理解，但是在实际项目中真正使用事件驱动模式的却很少。一部分原因是事件驱动模式缺少框架的支持，往往需要手工处理许多包括异常，顺序发送等工作。另一个原因是事件驱动的编程模型与顺序编程模型差异很大，在发出事件后就将程序的控制逻辑交给了事件的订阅者，在开发与问题排查时不是那么的直观与方便。所以接下来的部分是我在一些事件驱动模式上的实践经验，希望能对大家有所帮助。

### **对领域事件建模**

领域事件是一个对象，因此同样需要建模，定义它的数据结构。在开始定义我们的领域事件之前，还是先介绍一下业务场景。

当一个保险理赔申请提交，通过一系列的流程审核，确定理赔金额等数据无误后会有专人进行最后的二次审批，如果审批通过就可以支付给保险受益人相关的费用。从业务上看，理赔审批通过后，会有一连串的后台业务操作，首先是财务费用以及相关凭证的生产，然后是理赔通知书的生成与发送，如果保单由于理赔终止则需要对保单进行进一步的操作。这些业务行为无疑引入了数个 Aggregation 对象，肯定无法通过唯一的 Aggregation 在一个事务内完成，所以必须引入领域事件。以下是业务与事件的关系图:

![img](https://pic3.zhimg.com/80/v2-aeb6e5913f764dc90fc6f2594fc476ea_720w.jpg)

领域事件由 Aggregation 生成，在我们的这个场景中，Aggregation 就是理赔案件对象 — ClaimCase。而领域事件的名称的格式一般为产生这个事件的 Aggregation 的名称 + 产生事件的动词的过去式，这里产生事件的行为是审批 — approve，所以我们可以把这个领域事件的名称定为: `ClaimCaseApproved`。这其实和事件风暴中的建议也一样。

确定了名字之后，我们看一下事件内部的数据结构。`ClaimCaseApproved` 内部数据结构一般与产生它的 Aggragation 很相似，都是相对重要的领域对象数据，在我们的业务场景中，会有理赔的案件号，保险单号，事故日期等。需要注意的是，对于领域事件，通常需要增加额外的两个属性，一个是事件的发生日期，还有一个是事件的唯一编号。这两项对于问题的排查与调试，以及订阅事件方的处理都是必需的。以下是事件的示例代码:

```text
public class ClaimCaseApproved {
  private String eventId;
  private LocalDateTime occuredOn;
  private long claimCaseId;
  private long policyId;
  private LocalDateTime accidentDate;
  ……
}
```

### **事件的生成，发送与订阅**

有了数据模型之后，我们需要考虑的是在一个分层架构中，应该将事件相关的代码放置于何处。至今为止并没有一个统一的规则，所以我介绍之前项目中曾经尝试过的方法，其中有好的地方也有不方便的地方，具体选择何种，就留给你自己了。

一种做法是在领域服务中处理事件发送与订阅的逻辑，而事件的生成由领域对象，即 Aggregation 负责。我们先看一下示例代码:

```text
public class ClaimCase {
  public ClaimCaseApproved approve() {
    ……
  }
}
```

这里的代码很简单，`ClaimCase` 是一个 Aggregation 的领域对象，而 approve 方法执行的是审批的业务逻辑，它的返回结果就是它所产生的事件。接着看一下领域服务的代码:

```text
public class ClaimCaseService {
  private DomainEventPublisher publisher;
  ……
  public void approve() {
    ClaimCase claimCase = .....;
    ClaimCaseApproved claimCaseApproved = claimCase.approve();
    publisher.publish(claimCaseApproved);
    ……
  }
}
```

领域服务 `ClaimCaseService` 调用领域对象的 `approve` 方法获得生成的领域事件后进行发送，这里的 `DomainEventPublisher` 只是一个接口，具体的实现会依赖与基础设施层。这种做法的问题在于需要领域对象显式的返回事件对象，如果你的领域对象的这个方法正好需要返回值，而 Java 又是一门不支持多个返回值的语言，那么就有些尴尬了，比较直白的解决方案就是引入第三方库，返回一个类似 Tuple 的数据结构。

还有一种事件生成的可选方案是在领域对象内部保留一个数据结构存储产生的事件，然后在领域服务中调用特定的方法获取已经产生的事件，再发送，示例的代码如下:

```text
public class ClaimCase implements DomainEventGenerator {
  private Map<DomainEventType, List<DomainEvent>> registeredDomainEvents;
  public void approve() {
      ……
      registerDomainEvent(new ClaimCaseApproved());
  }
}
```

这次 `ClaimCase` 方法不再返回对应的领域事件，而是将事件保存在内部的 `Map` 中。接着看一下 `ClaimCaseService` 的变化:

```text
public class ClaimCaseService {
  public void approve() {
  …
      claimCase.approve();
      Map<DomainEventType, List<DomainEvent>> registeredDomainEvents = claimCase.getRegisteredDomainEvents();
      publisher.publish(registeredDomainEvents);
 }
}
```

领域服务 `ClaimCaseService` 在调用了 `claimCase` 的 `approve` 方法后，显式的调用了 `claimCase.getRegisteredDomainEvents` 方法，获取领域对象内部注册的领域事件，然后再发送。

另一种则是事件的发送，处理逻辑放在应用服务层，即 Application Service 中，具体的细节和领域服务中大同小异，我就不赘述了。但是有几点是需要牢记的:

1. 领域事件是领域逻辑的一部分，所以在领域层不应该依赖某些底层的框架或是中间件，例如直接依赖某个消息中间件的 api。
2. 事件的发送应该是异步非阻塞的，不应该阻塞当前处理的线程。
3. 设计上避免事件链的产生，即一个事件被处理后又产生了另一个事件，第二个事件的处理又产生了第三个事件，在设计没有注意的情况会变成一个环。(别问我是怎么知道的~~~)
4. 考虑最终一致性的解决方案，记好日志，以及事件丢失的处理与排查方案。

### **使用框架**

无论上述何种方法你可能都需要通过「观察者」这样的模式实现事件驱动的整个架构，但是如果你是使用 Java 的，就可以使用 Spring 这样的框架，通过依赖注入将事件的订阅，发布从领域模型中剥离出去。下面让我们看看如何使用 Spring 实现之前的例子:

```text
public class ClaimCaseApproved extends ApplicationEvent {
  ……
}
```

我们的领域事件变化不大，只是继承了由 Spring 提供的 ApplicationEvent 基类。 `ClaimCaseService` 中的 `publisher` 可以通过 Spring 的注入 Spring 的 `ApplicationPublisher`：

```text
@Autowired
private ApplicationEventPublisher applicationEventPublisher;
```

Spring 中把 Subscriber 称之为 Listener，这里我们可以定义自己的订阅者:

```text
@Component
public class FinanceFeeSubscriber {
  @Autowared
  private FinanceClaimFeeApplicationService financeClaimFeeApplicationService;

  @Async
  @EventListener
  public void handleClaimCaseApproved(ClaimCaseApproved event) {
      financeClaimFeeApplicationService.generateClaimFeeFor(…);
      ……
  }
}
```

上面的代码中我们借助 Spring 的能力注入了费用模块的应用层服务 `FinanceClaimFeeApplicationService`，然后通过 `@Async` 与 `@EventListener` 两个 annotation 声明了处理领域事件的异步方法，在方法中我们调用了应用层服务完成了由于理赔审批通过引起的费用相关处理逻辑。

这里需要注意的是要将方法声明为异步，这样处理事件的方法就会在一个独立的线程中运行，不会阻塞发布事件的线程。其次是这里业务上对事件处理的顺序没有要求，因此可以并行处理，按照上述的代码，可以再创建两个订阅者，负责理赔通知书生成和保单终止的业务处理，彼此没有影响。

如果你不想使用 Spring 提供能够的事件机制，可以考虑使用 Google Gauva 提供的 `EventBus`，它提供了类似的功能，使用起来也非常简单。

最后要注意的是，无论使用 Spring 还是 Guava，事件数据都是保存在内存中的，如果遇到服务重启很可能就会丢失未处理的数据，因此在项目中一定要记录日志并想好如何处理事件丢失的问题，必要时需要手工触发重发事件等机制。

## **小结**

事件驱动是非常贴合人类思维习惯的一种架构模式，而领域事件也是分析领域模型的优秀工具。虽然使用事件驱动的编程模型需要考虑一些额外的问题，例如线上的调试，事件的容错，重发等，但是毋庸置疑的是领域事件为我们提供了更好的解除耦合的手段，能够将大量复杂的业务逻辑拆分到不同的事件订阅者中处理，而彼此之间又保持着松耦合的关系。在项目允许的情况下，我强烈推荐领域事件这种模式，有兴趣的你不妨尝试一下！

# DDD实践手册(番外篇: 函数式编程与领域驱动设计)

这次番外篇的内容其实挺有意思，领域驱动设计与函数式编程又有什么关系呢？似乎这是八杆子打不着的两样东西，有这样的疑惑很正常，所以不妨继续往下看，听我慢慢的说。

## **函数式编程**

在开始介绍两者关系之前，先对函数式编程做一个简单的介绍。函数式编程与我们熟悉的结构化编程不同，前者属于声明式编程(Declarative Programming)，而后者属于命令式编程(Imperative Programming)，这是两种不同的编程范式。与我们熟悉的 C，C++，Java 相比，函数式编程语言有着自己非常显著的特点，一般被常常提及的有以下几点:

- 函数是一等公民，支持高阶函数，即函数本身能够作为另一个函数的参数或是返回值。
- 不变的数据结构，数据一旦生成就不允许修改，类似其他编程语言中的 constant 变量。
- 支持类似 Sum，Product 的抽象代数数据类型(ADT)。
- 支持 Functor，Monad 这样的类型类(Typeclasses)。

其实你会发现上述很多特性在近几年新出现的编程语言中都被大量使用，而一些老的编程语言也逐渐增加了更多的函数式编程的特性，例如 Java 从 8 开始正式加入了 lambda 的支持等。这也从另一方面说明函数式编程越来越被广大开发者所接受，并逐渐成为主流。

## **与领域驱动设计的结合**

使用传统的面向对象语言，例如 Java 能够实现领域驱动设计中的各种模式或是设计策略，这点毫无疑问。但是在某些方面利用函数式编程的某些特性往往能够取得更加好的效果，例如更简洁的代码，更好的封装性，以及对外部框架更少的依赖。接下来我会使用 Kotlin 实现一些领域驱动设计中的概念，大家会看到一些截然不同的东西。

之所以选择 Kotlin 作为演示的语言，一则它作为 JVM 平台上的新锐语言吸收了大量函数式编程的特性，同时它又不像 Scala 那么复杂，语法上更为简单明了些。而不选用 Groovy 的原因是我不太熟悉，充其量只会写写 Gradle 的构建脚本

### **模块**

作为 DDD 中的一个概念，模块(Module)却很少被提及。一方面的原因是 DDD 的几本书中对于模块的阐述有些过于抽象，只是谈到了一些指导意见和简单的示例代码。另一方面是很多时候开发者容易把「模块」与「限界上下文」搞混，但是在 DDD 的原书中明确说明了两者是不同的。一般对模块的使用是把「相同业务概念」的对象放在一起，包括聚合，包括领域服务，包括工厂，仓库。而模块的名称应该是统一语言的一部分，是与业务相关的名词。

如果使用 Java 实现模块，那么我们的选择只有 Java 所提供的 package 机制。在大部分情况下 package 都表现的不错，但是在某些情况下，会有一些小小的问题。假设我们的系统中有两个模块，分别对应保险理赔的两个阶段，申请和受理，这两个模块下各自有一个针对理赔案件的聚合对象，在 Java 如何实现呢？大致代码是这样的:

```text
package com.xxx.claim.application;

public class ClaimCase {
    ……
}

package com.xxx.claim.acceptance;

public class ClaimCase {
    ……
}
```

你可以使用 package 表示两个不同的模块，然后在两个模块下各自有一个名为 ClaimCase 的聚合。然后如果在某个 Service 中需要同时用到这两个聚合，你就只能用类似 `com.xxx.claim.application.ClaimCase` 这样的全限定名来引用不同模块下的同名聚合，显得非常冗繁。或者你可以将模块名放在聚合之前，类似 `AppliedClaimCase`，但有时候这样的可读性又不好，不容易其他人理解。

我们看一下 Kotlin 的一种可选方案，代码如下:

```text
package com.xxx.claim

object Application {
  class ClaimCase {
      ……
  }
}

object Acceptance {
  class ClaimCase {
      ……
  }
}
```

我们可以通过 Nested Class 的特性将业务概念类似的对象都放在一个 `object` 中，而引用不同对象时就很方便: `val newClaimCase = Application.ClaimCase()` ，同时这样的代码可读性更好，对于揭示业务含义的能力也越强。

### **更加自由的方法定义**

上一条可能和函数式编程的关系不大，很多借助的是 Kotlin 的特性，但是不难发现函数式编程语言往往都提供了更为灵活的包结构，或者说是编程的模块结构，比如刚才的例子使用 Scala 的 trait 也能轻松的实现。而对于方法的定义和使用上则更加凸显函数式编程的灵活。

Java 作为典型的面向对象编程语言，所有的方法都必须依附在类上。但是在实际项目中，并不是所有的方法都要归属某个类的，例如在理赔模块下有些方法是可以在所有理赔子模块中使用的，那么如何定义这些模块内的共用方法呢？ 此时一种常见的做法是定义一个领域服务类，`ClaimService`，但是这样往往有些牵强，容易把许多无处安放的方法都放在里面。

在 Kotlin 中就可以拥有更为优雅的解决方案。Kotlin 中允许我们更为自由的定义方法，或者称之为函数。针对上面的例子，我们可以在 `com.xxx.claim` 的 package 下创建名为 `claim.kt` 的文件，然后直接在文件中定义方法:

```text
package com.xxx.claim

fun <E: DomainEvent> publishClaimEvent(event: E) {
    ……
}
```

当需要调用方法时就可以直接调用而无需创建一个用来包装这些方法的服务类，不仅减少了不必要的封装，也更加符合业务意义。

同时这也鼓励我们更多的使用短小，简洁的方法，然后通过方法组合形成更大的，更复杂的方法，从而增加系统的灵活性与代码的复用。而对方法进行自由的组合也是函数式编程的一大特性。

### **更优雅的工程模式**

「工厂」也是领域驱动设计中的一个核心概念，用来创建领域对象，特别是封装聚合的创建。在 Java 中没有直接对工厂的支持，需要采用设计 模式中的工厂模式。在功能上并没有什么缺陷，但问题在于多了不少冗余的代码。一种做法是针对每个领域对象创建一个工厂类，但是这样等于代码和文件数要翻一倍，太麻烦。另一种就是在领域对象上创建一个静态方法，用来创建对象的实例，同时还要把构造函数变为私有。

但是在 Kotlin 中可以通过伴生对象很方便的完成这一点:

```text
class Accident private constructor(val dateOfAccident: LocalDateTime, val accidentType: AccidentType){
    companion object Factory {
        fun create(dateOfAccident: LocalDateTime, accidentType: AccidentType): Accident {
            return Accident(dateOfAccident, accidentType)
        }
    }
}

//创建 Accident
val accident = Accident.create(LocalDateTime.now(), AccidentType.CRITICAL)
```

通过伴生对象我们能够更好的封装领域对象的创建逻辑，同时将创建的逻辑从领域对象中与其他领域逻辑隔离开，放入到一个专门的伴生对象中，但是又没有增加额外的源文件。

### **模式匹配与策略模式**

策略模式(Strategy Pattern)是开发者平时使用频率很高的一种设计模式，也是一种非常实用的模式。它能将类似的算法分散在不同的子类中，免去大量繁琐的 `if` 分支语句。但是在实际使用中，往往会遇到这样那样的问题。我们来看一个实际的例子。

在保险理赔金额的计算过程中需要按照投保险种计算赔付的金额，而不同类型险种计算时的算法是不同的，理所当然的这是一个应用策略模式的好机会。简单假设我们现在有固定期限的寿险，给付型的医疗保险以及账户型的万能险三种不同产品，它们的计算方式各不相同。于是你很快的定义了一个计算赔付金额的接口以及对应具体算法的实现类，代码如下:

```text
public interface ClaimPaymentCalculator {
  ……
}

public class LifeInsuranceClaimPaymentCalculator implements ClaimPaymentCalculator {
  ……
}

……
```

但在定义具体计算金额方法的时候你犯难了，这个方法的参数怎么定呢？固定期寿险计算需要输入基本保额，而医疗险的计算则不仅需要输入基本保额还需要输入住院天数，每日住院津贴的金额，万能险则需要输入基本保额和投资账户内的余额，也就是说这些计算规则的输入参数都是不同的。

这时你有几种选择，最简单的就是设计一个通用的数据结构，把这三种产品计算的数据都放进去，但是这样做的缺点很明显，其一是以后如果增加新的产品，再有新的计算参数，你就要修改这个通用的数据结构，非常的不稳定。其二是调用这个方法的代码可能遗漏某些参数，而这样的 bug 只可能在测试或是运行时发现，不能在编译时进行检查，无疑也是一个大问题。

那么 Kotlin 与函数式编程中又有什么好办法呢？

```text
sealed class ClaimPaymentCalculator
class LifeInsuranceClaimPaymentCalculator(val basicInsuredAmount: BigDecimal) : ClaimPaymentCalculator() {
    fun doCalculate(): BigDecimal {
        ……
    }
}

class HealthInsurancePaymentCalculator(val basicInsuredAmount: BigDecimal) : ClaimPaymentCalculator() {
    fun doCalculate(daysInHospital: Int, dailyExpense: BigDecimal): BigDecimal {
        ……
    }
}

class UniversalInsurancePaymentCalculator(val basicInsuredAmount: BigDecimal) : ClaimPaymentCalculator() {
    fun doCalculate(accountBalance: BigDecimal): BigDecimal {
        ……
    }
}

fun calculateClaimPayment(calculator: ClaimPaymentCalculator): BigDecimal {
    ……
    return when (calculator) {
        is LifeInsuranceClaimPaymentCalculator -> calculator.doCalculate()
        is HealthInsurancePaymentCalculator -> calculator.doCalculate(daysInHospital, BigDecimal(dailyExpense))
        is UniversalInsurancePaymentCalculator -> calculator.doCalculate(BigDecimal(accountBalance))
    }
}
```

上面的代码中我们定义了计算赔付金额的接口以及三个具体的实现类，但是这个接口只是一个标识性的接口，并没有定义计算的方法。具体计算的方法在实现的子类中。可以看到这些计算方法的参数是不一样的。然后在 `calculateClaimPayment` 中通过模式匹配(pattern match)，调用了不同的计算方法，而且能够传入不同的参数，保证了计算接口参数的最小化。同时由于接口上的 `sealed` 关键字，编译器在编译阶段就能保证我们没有遗漏需要处理的子类，整个代码逻辑非常清晰，且不会出错。

## **似乎缺了点什么……**

谈及函数式编程，如果没有说到抽象代数类型，函子，单子，幺半群(我知道，你们其实就想听这个)就好象半夜饥肠辘辘想吃方便面的时候，发现缺了调味包。虽然能吃，但是却没了什么味道。但是因为篇幅的原因，这次就先写到这，下一篇的番外篇会介绍如何使用函数式编程中的 Monad(对，就是那个「说白了不过就是自函子范畴上的一个幺半群而已」的 Monad)，Functor 在领域驱动设计中的应用，希望你会喜欢。

# DDD实践手册(番外篇: 领域驱动设计中的Monad)

上一篇文章中介绍了一些如何在领域驱动设计中使用函数式编程，进而提升代码可用性的技巧。其中缺少了使用函数式编程中 Typeclass(类型类) 的应用场景，恰好最近需要对重构遗留代码中的一个模块(看我拖更的频率就知道这个重构不简单 )，经过思考之后觉得这项重构可以借助 Monad 提升可维护性，所以稍作整理后便有了这篇文章。希望能给大家带来一些新的启发。

## **如何优雅的实现业务规则校验**

具体的业务需求其实不难，在保单正式生效之前需要做一系列的校验，保证相关业务数据的正确，例如财务数据，保费数据等。虽然逻辑比较简单，大部分都是查询数据库，然后按照结果判断是否为正常数据，但是规则的数量非常多。现有的实现中将所有逻辑都在一个类中完成，单个文件的代码长度超过 3000 行，虽然做了一些简单的封装，例如将规则提炼为单个的私有函数，但是依然难以管理与测试，后续新规则的开发与维护都很不方便。

在之前的文章中我介绍过如何使用 Specification 模式对领域对象进行校验，分离领域层的逻辑与规则校验的逻辑。在具体实现的过程中如果能够合理运用函数式编程中的一些特性能够帮助我们编写更加流畅的代码，并更好的管理复杂度。

开始我们的重构之前，先简单看一下现有代码是怎么样的:

```text
String result = StringUtils.EMPTY;
result = checkPolicyProduct(policy);
if (StringUtils.isNotEmpty(result) {
    throw new ValidationException(result);
}

result = checkXXXXX(policy);
......
```

上述代码的逻辑不难理解，`checkXXXX` 是当前类中用以进行业务规则校验的私有方法，它接受的参数都是类型为 `Policy` 的领域实体，并且会返回一个字符串，如果字符串内容为空则表示通过校验，否则就包含了引起校验失败原因的描述。

我们先不考虑原有接口设计是否合理，先想办法在不改变这些校验方法接口的情况下如何重构，毕竟我们希望先能够复用这些已经存在的业务代码。

## **使用 Either 管理异常**

因为篇幅的原因，我这里就不介绍 Monad 的定义，毕竟这不是一句话就能说明白的东西: **一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已** (大雾)。但是学习 Monad 的过程无疑是非常有价值的，我推荐可以从 **[Functors, Applicatives, And Monads In Pictures - adit.io](https://link.zhihu.com/?target=http%3A//adit.io/posts/2013-04-17-functors%2C_applicatives%2C_and_monads_in_pictures.html)** 开始，有了一些概念后再阅读更多的材料。额外提一下，这篇文章的作者也是 **[算法图解 (豆瓣)](https://link.zhihu.com/?target=https%3A//book.douban.com/subject/26979890/)** 的作者，同样也是非常值得一读的作品。

如果你是 Java 程序员，那么你日常使用的 `List` 与 `Optional` 对象都是 Monad，所以不必过于纠结与概念，轻松往下看就好。

### **Either 类型**

在开始介绍新的校验实现之前，先介绍一下 `Either` 这个数据类型，同时为了更好的展示函数式编程的优点，我依然会使用 Kotlin 编写示例代码。`Either` 并不是 Kotlin 内建支持的数据类型，因此我也会引入第三方库 **[Λrrow](https://link.zhihu.com/?target=https%3A//arrow-kt.io/)** 的支持。如果你是 Java 程序员也不必担心，可以通过引入 **[Vavr](https://link.zhihu.com/?target=https%3A//www.vavr.io/)** 来支持 `Either` 。

```kotlin
@higherkind sealed class Either<out A, out B>
```

上面是 `Either` 的定义，它是一个由两部分组成的数据类型，即左值(Left Value) 和右值(Right Value)，这两个值的类型可以是不同的。任何一个 `Either` 的实例，要么是左值，要么是右值，没有例外，因此 `Either` 也是一个 ADT，即抽象代数类型。

实际使用中，我们往往使用 `Either` 封装函数调用的异常，你可能在其他的库中看到过类似的应用，不同的是使用的数据类型可能是 `Try`，其实这两者非常类似，只是无论 **[Λrrow](https://link.zhihu.com/?target=https%3A//arrow-kt.io/)** 还是 **[Vavr](https://link.zhihu.com/?target=https%3A//www.vavr.io/)** 都把 `Try` 列为了 `Deprecated`，不再建议使用，所以这次我们也是使用 `Either` 编写示例代码。

通常我们使用左值表示异常，而右值表示正常调用后的返回结果，即: `Either<Throwable, T>` 。接着让我们开始校验规则的接口设计。

### **Spec 接口**

先看一下我们的 `Spec` 接口:

```kotlin
interface Spec<T> {
    fun validate(entity: T): Either<Throwable, T>
}
```

这个接口很简单，其中只有一个 `validate` 方法，接受一个领域对象，然后返回一个封装了异常或是正常结果的 `Either` 。同时为了能够更好的管理规则，我们使用 `Composition` 组合模式设计一个表示规则集的数据结构:

```kotlin
abstract class SpecSet<T> : Spec<T> {
    private val specs: List<Spec<T>>

    init {
        this.specs = Collections.unmodifiableList(buildSpecs())
    }

    override fun validate(entity: T): Either<Throwable, T> {
        return this.specs.fold(Either.Right(entity))
        { result, spec ->
            return when (result) {
                is Either.Left -> result
                is Either.Right -> result.flatMap { e -> spec.validate(e) }
            }
        }
    }

    abstract fun buildSpecs(): List<Spec<T>>
}
```

`SpecSet` 是一个抽象类，它同样实现了 `Spec` 接口，而它在内部使用 `List` 对象保存多个 `Spec` 接口的对象。通过继承 `SpecSet` ，并实现抽象方法 `buildSpecs` 就能完成规则集数据的构建。

`SpecSet` 中的 `validate` 方法会依次调用 `specs` 中每个 `Spec` 对象的 `validate` 方法完成校验。只是与单纯的循环不同，这里我们使用了 `fold` 方法，这个方法与我们熟悉的 `reduce` 方法类似，会将容器中的每个元素作为方法调用的参数进行规约。

我们会按照每次调用结果是左值(异常)，还是右值(正常)决定下一次是否继续执行后续的检查。而 `Either` 上的 `flatMap` 方法正是体现了 Monad 的便利之处。

完成了接口定义之后让我们看看如何具体使用。

### **应用**

我们先通过实现 `Spec` 接口定义了三个校验规则: **是否已经通过核保**，**保费是否已经缴纳**，**保险产品是否有效**，示例代码如下:

```kotlin
class UnderwritingValidateSpec : Spec<Policy> {
    override fun validate(policy: Policy): Either<Throwable, Policy> {
        if (......) {
            return Either.Left(RuntimeException("Invalid underwriting data"))
        }
        return Either.Right(policy)
    }
}

class PremiumValidateSpec : Spec<Policy> {
    ......
}

class PolicyProductValidateSpec : Spec<Policy> {
    ......
}
```

代码中的逻辑很容易明白，如果能够通过校验则会以右值的形式返回传入的 `Policy` 对象，否则会返回用左值包装的`RuntimeException` 对象。

接着我们定义一个用于保单承保前的规则校验集合:

```kotlin
class PolicyIssueValidateSpecSet: SpecSet<Policy>() {
    override fun buildSpecs(): List<Spec<Policy>> {
        return listOf(UnderwritingValidateSpec(), PremiumValidateSpec(), PolicyProductValidateSpec())
    }
}
```

接着我们就能注入规则集并运行了:

```kotlin
val sp: Spec<Policy> = PolicyIssueValidateSpecSet()
sp.validate(policy).mapLeft { e -> throw e }
```

这么做的优点在于能够把不同的规则放置在不同的目录之下管理，并能按照需要在规则集层面进行组装。规则的运行，定义，组装都在不同的类中完成，互相没有紧密耦合的关系，而通过 `Either` 能够很方便的封装校验过程中发生的异常，减少不必要的代码。

## **小结**

从上面寥寥的数十行代码中我们就通过函数式编程的 Monad 的特性实现了一个不错的规则验证框架，在这里 Monad 为我们封装了由于异常引起的副作用，使得各个规则校验函数的调用可以组合，从而让复用变为可能。类似的例子其实还有很多，例如使用其他的类型类从函数层面完成各式各样的组合操作，能够更为方便的支持并行计算。

而我们的例子其实还能进一步提升，细心的你一定看出我们现在校验的逻辑是一种短路逻辑，即遇到第一个校验失败时就会停止调用后续的校验方法。但是实际项目中我们则希望即使遇到了异常也能继续向下执行。当所有校验方法执行完成后，将所有的异常信息汇总后在返回给用户。需要完成这样的修改并不难，作为读者的你不妨自己尝试一下，我想你一定会获得更为深入的函数式编程体验！