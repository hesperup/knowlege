# [STM32 HAL库关于串口中断烧录程序后可以正常运行，断电重启后无法进入中断的问题分析以及解决方法]

**1、情景描述：**

　　最近在做一个项目，X86的上位机通过串口控制MCU，使用串口中断接收上位机数据时，MCU在上电的情况下烧录程序，可以正常接收上位机的数据，在断电重启后，一直进入不了中断回调函数，上电的情况是X86上电，MCU也同时上电。

 

**2、原因分析：**

　　造成这个的原因是因为硬件上电的时候，因为X86跟MCU是同时上电的，上电后会把串口的电平拉高，这个高电平触发了MCU的串口中断，导致MCU的串口中断误以为接收到了一个数据，例如 HAL_UART_Receive_IT(&huart1, (uint8_t *)Rx_buff, 5) 这里，上电后MCU误以为接收了一个数据，还剩下4个数据没有接收，然后上位机每次发送5个数据过来后MCU中断数据接收个数错误，所以一直无法进入中断回调函数。

　　我们看到 HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart) ，里面的 **RxXferCount** 是告诉我们中断要接收的剩余数据量大小，根据上面举例子的话，上电时因为那个高电平的原因导致 RxXferCount 变成了4，如下图打印信息所示

　　![img](C:\Users\putao\Documents\Blog\嵌入式知识\UART串口.assets\1433771-20191028171317619-1654556616.png)

 　接着我们重新看回 HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart) 函数里的调用回调函数部分，下图所示，发现 **RxXferCount** 要为0的时候才会调用中断回调函数，依旧以上面例子说明，当MCU误以为上电时的高电平为数据时，上位机再发送5个数据下来，RxXferCount 就永远无法变成0，所以导致一直进入不了中断回调函数。

　　![img](C:\Users\putao\Documents\Blog\嵌入式知识\UART串口.assets\1433771-20191028170453162-1429918606.png)

 

 **3、解决方法：**

　　**3.1软件解决方法**

　　　　软件解决的时候，我们要知道导致这个问题的根源是 RxXferCount 这个值被误判了，所以我们只需要在上电的时候，对这个值进行修正即可；

　　　　首先我们定义一个标志位，用来标志MCU的状态是刚上电的状态　　

```
char uart_error_flag=0;
```

　　　　接着我们编写函数对 RxXferCoun 值进行处理

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/***
 函数名：void uart_error(void)
 说  明：解决刚上电时，由于串口电平拉高，导致串口中断误以为接收到了一个字节，
        导致后面接收数据个数一直错误，无法进入中断回调函数问题
 传入值：无
 传出值：无
**/
void uart_error(void)
{
      if( (huart1.RxXferCount < Rxdsize) && (uart_error_flag==0) )
        { 
            /*RxXferCount 告诉我们剩余空间大小，如果剩余空间和总空间不一样，则说明中断收到数据了*/
            printf("huart1.RxXferCount = %d\r\n",huart1.RxXferCount);    
            uart_error_flag = 1;
            huart1.RxXferCount = 5; //修改剩余空间，防止无法进入回调        
        }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　　　最后我们在 main 函数里的 while 循环前调用即可

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
int main(void)
{

  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init(); //初始化打印信息串口
  MX_USART1_UART_Init(); //初始化中断接收串口  
  HAL_UART_Receive_IT(&huart1, (uint8_t *)Rx_buff, Rxdsize); //打开串口中断接收
  uart_error(); //处理上电时串口中断误判的问题
  while (1)
  {
   /* 注意要在中断回调函数里重新打开串口中断接收，否则串口中断接收只能接收一次 */
  }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　**3.2 硬件解决方法**

　　　　硬件解决方法比较粗暴，就是做一个电源延时电路，等X86重新上电后，再给MCU上电。

 

**补充说明：**

　　使用DMA接收时候不会出现这种情况，不过使用DMA接收，如果上位机发送数据过快，会出现数据粘包现象，例如上位机发送是数据一包是5个数据，如果上位机发送数据过快（20ms以内），MCU就好会把接收到的好几包数据当做一包数据来处理，例如把3包数据当做1包数据来处理，这样MCU就会误以为一包数据的15个了，出现误判的情况，不过它接收的数据是准确的，就是分包能力没有串口中断强。







**通用异步收发器**（Universal Asynchronous Receiver/Transmitter)，通常称作**UART，是一种串行、异步、全双工的通信协议**，在嵌入式领域应用的非常广泛。

　　UART作为异步串行通信协议的一种，工作原理是将传输数据的每个二进制位一位接一位地传输。在UART通信协议中信号线上的状态为高电平时代表‘1’，信号线上的状态为低电平时代表‘0’。比如使用UART通信协议进行一个字节数据的传输时就是在信号线上产生八个高低电平的组合。

- 串行通信是指利用一条传输线将数据一位位地顺序传送，也可以用两个信号线组成全双工通信，如rs232。特点是通信线路简单，利用简单的线缆就可实现通信，降低成本，适用于远距离通信，但传输速度慢的应用场合。
- 异步通信以一个字符为传输单位，通信中两个字符间的时间间隔多少是不固定的，然而在同一个字符中的两个相邻位间的时间间隔是固定的。通俗说是两个uart设备之间通信的时候不需要时钟线，这时候就需要在两个uart设备上指定相同的传输速率，以及空闲位、起始位、校验位、结束位，也就是遵循相同的协议。
- 数据传送速率用波特率来表示，即每秒钟传送的二进制位数。例如数据传送速率为120字符/秒，而每一个字符为10位（1个起始位，7个数据位，1个校验位，1个结束位），则其传送的波特率为10×120＝1200字符/秒＝1200波特。

数据通信格式如下图：

![img](C:\Users\putao\Documents\Blog\嵌入式知识\UART串口.assets\v2-2ebc83957b33a1525468eed46d3139c8_720w.jpg)UART的数据传输格式

其中各位的意义如下：

**空闲位：**

　　UART协议规定，当总线处于空闲状态时信号线的状态为‘1’即高电平，表示当前线路上没有数据传输。

**起始位：**

　　每开始一次通信时发送方先发出一个逻辑”0”的信号（低电平），表示传输字符的开始。因为总线空闲时为高电平所以开始一次通信时先发送一个明显区别于空闲状态的信号即低电平。

**数据位：**

　　起始位之后就是我们所要传输的数据，数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。如ASCII码（7位），扩展BCD码（8位）。先发送**最低位**，最后发送**最高位**，使用低电平表示‘0’高电平表示‘1’完成数据位的传输。

**奇偶校验位：**

　　数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。校验位其实是调整个数，串口校验分几种方式：

- 1、无校验（no parity）。
- 2、奇校验（odd parity）：如果数据位中“1”的数目是偶数，则校验位为“1”，如果“1”的数目是奇数，校验位为“0”。
- 3、偶校验（even parity）：如果数据为中“1”的数目是偶数，则校验位为“0”，如果为奇数，校验位为“1”。
- 4、mark parity：校验位始终为1（不常用）。
- 5、parity：校验位始终为0（不常用）。

**停止位：**

　　它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备之间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟的机会。停止位个数越多，数据传输越稳定，但是数据传输速度也越慢。

## ***波特率：***

数据传输速率使用波特率来表示。单位bps（bits per second），常见的波特率9600bps、115200bps等等，其他标准的波特率是1200，2400，4800，19200，38400，57600。举个例子，如果串口波特率设置为9600bps，那么传输一个比特需要的时间是1/9600≈104.2us。

![img](C:\Users\putao\Documents\Blog\嵌入式知识\UART串口.assets\v2-8047abfec34163a8bccd78d66d35b90a_720w.jpg)

以9600，8-N-1（9600波特率，8个数据位，没有校验位，1位停止位）为例，这是目前最常用的串口配置，现在我们传输“O”“K”两个ASCII值，“O”的ASCII为79，对应的二进制数据为**01001111**，“K”对应的二进制数据为**01001011**，传输的格式数据如下图所示：

![img](C:\Users\putao\Documents\Blog\嵌入式知识\UART串口.assets\v2-fb33146780ca46ad6bd95509abf638e7_720w.jpg)

串口波特率为9600，1bit传输时间大约为104us，传送一个数据实际是10个比特（开始位-8个数据位-停止位），一个bytes传输速率实际为9600*8/10=7680bps。