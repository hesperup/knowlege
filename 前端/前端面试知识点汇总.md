# 前端基础

## 浏览器

- 浏览器的缓存机制：强缓存与协商缓存，以及其区别是什么？
- 存储相关：localstorage、sessionStorage、cookie等分别是做什么用的，区别是什么？
- 浏览器的network面板里面的东西，主要是timing下面的时间段代表的都是什么意思？TTFB是什么？
- 浏览器的performance用过吗，是用来干什么的？
- 跨域的原理，跨域的实现方式有哪几种？
- 浏览器环境下的event loop是怎样的？其实也就是宏任务和微任务，可以看下[这篇文章](https://juejin.cn/post/6873007808564953096#heading-1)

## JavaScript

### 基础数据类型和引用数据类型

- 基础数据类型：Undefined、Null、Boolean、String、Number、Symbol
- 引用数据类型：Object、Array、Date、RegExp、Function
- 此处可能会考察，typeof、instanceof；包括手动实现以下typeof和instanceof

```
// 实现typeof
function type(obj) {
	return Object.prototype.toString.call(a).slice(8,-1).toLowerCase();
}
复制代码
// 实现instanceof
function instance(left,right){
    left=left.__proto__
    right=right.prototype
    while(true){
       if(left==null)
       	  return false;
       if(left===right)
          return true;
       left=left.__proto__
    }
}
复制代码
```

### 原型链

理解原型链是做什么的，也就是：实例.**proto** === 构造函数.prototype

```
Object.prototype.__proto__ === null // true
Function.prototype.__proto__ === Object.prototype // true
Object.__proto__ === Function.prototype // true
复制代码
```

有个比较好的问题，可以思考下：

```
function F() {}
Object.prototype.b = 2;
F.prototype.a = 1;
var f = new F();
console.log(f.a) // 1
console.log(f.b) // 2
console.log(F.a) // undefined
console.log(F.b) // 2
复制代码
```

上面代码，为什么F.a是undefined？

```
function F() {}
Object.prototype.b = 2;
Function.prototype.a = 1;
var f = new F();
console.log(f.a) // undefined
console.log(f.b) // 2
console.log(F.a) // 1
console.log(F.b) // 2
复制代码
```

上面代码，为什么f.a是undefined？

```
function F() {}
F.prototype.a = 1;
var f1 = new F()
F.prototype = {
    a: 2
}
var f2 = new F()
console.log(f1.a) // 1
console.log(f2.a) // 2
复制代码
```

### 继承

继承的几种方式：

- 原型链继承：

  ```
  function SuperType() {
    this.name = 'Yvette';
    this.colors = ['red', 'blue', 'green'];
  }
  SuperType.prototype.getName = function () {
      return this.name;
  }
  function SubType() {
      this.age = 18;
  }
  SubType.prototype = new SuperType();
  SubType.prototype.constructor = SubType;
  
  let instance1 = new SubType();
  instance1.colors.push('yellow');
  console.log(instance1.getName());
  console.log(instance1.colors); // ['red', 'blue', 'green', 'yellow']
  
  let instance2 = new SubType();
  console.log(instance2.colors); // ['red', 'blue', 'green', 'yellow']
  复制代码
  ```

  缺点：

- - 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。(引用类型值被所有实例共享)

- - 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数

- 构造函数继承：

  ```
  function SuperType(name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
  }
  function SubType(name) {
      SuperType.call(this, name);
  }
  let instance1 = new SubType('draven');
  instance1.colors.push('yellow');
  console.log(instance1.colors);  // ['red', 'blue', 'green', 'yellow']
  
  let instance2 = new SubType('ben');
  console.log(instance2.colors);  // ['red', 'blue', 'green']
  复制代码
  ```

  优点：

- - 可以向超类传递参数

- - 解决了原型中包含引用类型值被所有实例共享的问题 缺点:

- - 方法都在构造函数中定义，函数复用无从谈起。

- - 超类型原型中定义的方法对于子类型而言都是不可见的。

- 组合继承：

  ```
  function SuperType(name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
  }
  SuperType.prototype.sayName = function () {
      console.log(this.name);
  }
  function SuberType(name, age) {
      SuperType.call(this, name);
      this.age = age;
  }
  SuberType.prototype = new SuperType()
  SuberType.prototype.constructor = SuberType
  
  let instance1 = new SuberType('draven', 25);
  instance1.colors.push('yellow');
  console.log(instance1.colors); // ['red', 'blue', 'green', 'yellow']
  instance1.sayName(); //draven
  
  let instance2 = new SuberType('ben', 22);
  console.log(instance2.colors);  // ['red', 'blue', 'green']
  instance2.sayName();//ben
  复制代码
  ```

  缺点：

- - 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。

  优点：

- - 可以向超类传递参数

- - 每个实例都有自己的属性

- - 实现了函数复用

- 寄生组合式继承，寄生组合继承是引用类型最理性的继承范式，使用Object.create在组合继承的基础上进行优化：

  ```
  function SuperType(name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
  }
  SuperType.prototype.sayName = function () {
      console.log(this.name);
  }
  function SuberType(name, age) {
      SuperType.call(this, name);
      this.age = age;
  }
  SuberType.prototype = Object.create(SuperType.prototype)
  SuberType.prototype.constructor = SuberType
  let instance1 = new SuberType('draven', 25);
  instance1.colors.push('yellow');
  console.log(instance1.colors); //[ 'red', 'blue', 'green', 'yellow' ]
  instance1.sayName(); //draven
  
  let instance2 = new SuberType('ben', 22);
  console.log(instance2.colors); //[ 'red', 'blue', 'green' ]
  instance2.sayName();//ben
  复制代码
  ```

- ES6继承：

  ```
  class SuperType {
      constructor(age) {
          this.age = age;
      }
  
      getAge() {
          console.log(this.age);
      }
  }
  
  class SubType extends SuperType {
      constructor(age, name) {
          super(age); // 调用父类的constructor(age)
          this.name = name;
      }
  }
  
  let instance = new SubType(18, 'draven');
  instance.getAge(); // 18
  复制代码
  ```

- - 类的内部所有定义的方法，都是不可枚举的。(ES5原型上的方法默认是可枚举的)

### 闭包：

- 柯理化：

```
// 实现固定参数的curry
function add(a, b, c, d) {
    return a + b + c + d
}

function curry(fn) {
    const length = fn.length
    let params = []
    return function func() {
        params = params.concat([].slice.call(arguments))
        if (params.length === length) {
            const res = fn.apply(null, params);
            params = [];
            return res;
        } else {
            return func;
        }
    }
}

const addCurry = curry(add);
console.log(addCurry(1, 2)(3, 4)); // 10
console.log(addCurry(2)(3)(4)(5)); // 14
复制代码
// 实现随意参数的柯理化
function add() {
    let params = [].slice.call(arguments);
    function func() {
        params = params.concat([].slice.call(arguments))
        return func;
    }
    func.toString = () => {
        return  params.reduce((a, b) => {
            return a + b;
        }, 0);
    }
    return func;
}

console.log(add(1, 2)(3, 4)); // 10
console.log(add(2)(3)(4)(5)); // 14
复制代码
```

- 防抖和节流：

函数防抖和节流，都是控制事件触发频率的方法。

```
// 防抖
export function debounce(func, wait, immediate) {
    let timeout, args, context, timestamp, result;

    let nowTime = Date.now || function () {
        return new Date().getTime();
    };

    const later = function () {
        let last = nowTime() - timestamp;

        if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
        } else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            }
        }
    };

    return function () {
        context = this;
        args = arguments;
        timestamp = nowTime();
        let callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }

        return result;
    };
};
复制代码
// 节流
function throttle(fn, threshhold) {
    let timeout
    let start = new Date;
    threshhold = threshhold || 160
    return function () {
        const context = this, args = arguments, curr = new Date() - 0
        clearTimeout(timeout)//总是干掉事件回调
        if (curr - start >= threshhold) {
            fn.apply(context, args)
            start = curr
        } else {
            //让方法在脱离事件后也能执行一次
            timeout = setTimeout(function(){
                fn.apply(context, args)
            }, threshhold);
        }
    }
}
复制代码
```

### var/let/const

这部分主要考查对let和var的理解，变量提升等。

看下面这个代码的执行结果是什么？

```
var foo = {n: 1};
var bar = foo;
foo.x = foo = {n: 2};

bar = ？
foo = ？
复制代码
```

上面的执行结果是：`bar = {n:1,x:{n:2}}; foo={n:2}`;

```
a();
var a=3;
function a(){
alert(10)
}
alert(a)
a=6;
a()
复制代码
```

上面的执行结果是：`10 3 error`;最后的error是因为a不是个function；

### == 与 ===

隐式转换的步骤： 主要搞明白在强等和双等的时候做了什么事情，也就好理解了。

强等(===)会首先比较两边的类型是否相同，如果不同则直接返回false；如果类型相同的话，则是按照==来判断的，我们来看下==所引起的隐式转换。

#### 双等号引起的隐式转换

一、首先看双等号前后有没有NaN，如果存在NaN，一律返回false。

二、再看双等号前后有没有布尔，有布尔就将布尔转换为数字。（false是0，true是1）

三、接着看双等号前后有没有字符串, 有三种情况：

```
1、对方是对象，对象使用toString()或者valueOf()进行转换；

2、对方是数字，字符串转数字；（前面已经举例）

3、对方是字符串，直接比较；

4、其他返回false
复制代码
```

四、如果是数字，对方是对象，对象取valueOf()或者toString()进行比较, 其他一律返回false

五、null, undefined不会进行类型转换, 但它们俩相等

#### .toString()方法和.valueOf()方法数值转换

通常情况下我们认为，将一个对象转换为字符串要调用toString()方法，转换为数字要调用valueOf()方法，但是真正应用的时候并没有这么简单，看如下代码实例:

```
let obj = {
 name: "draven",
 age: 28
}
console.log(obj.toString()); //[object Object]
复制代码
```

同理，我们再看valueOf()方法：

```
let arr = [1, 2, 3];
console.log(arr.valueOf());//[1, 2, 3]
复制代码
```

从上面的代码可以看出，valueOf()方法并没有将对象转换为能够反映此对象的一个数字。相反，我们用toString()

```
let arr = [1, 2, 3];
console.log(arr.toString());//1,2,3
复制代码
```

**注：很多朋友认为，转换为字符串首先要调用toString()方法， 其实这是错误的认识，我们应该这么理解，调用toString()方法可以转换为字符串，但不一定转换字符串就是首先调用toString()方法。**

我们看下下面代码：

```
let arr = {};
arr.valueOf = function () { return 1; }
arr.toString = function () { return 2; }
console.log(arr == 1);//true

let arr = {};
arr.valueOf = function () { return []; }
arr.toString = function () { return 1; }
console.log(arr == 1);//true
复制代码
```

上面代码我们可以看出，转换首先调用的是valueOf()，假如valueOf()不是数值，那就会调用toString进行转换！

```
let arr = {};
arr.valueOf = function () { return "1"; }
arr.toString = function () { return "2"; }
console.log(arr == "1");//true
复制代码
```

假如"1"是字符串，那么它首先调用的还是valueOf()。

```
let arr = [2];
console.log(arr + "1");//21
复制代码
```

上面的例子，调用的是toString（）;因为arr.toString（）之后是2。

转换过程是这样的，首先arr会首先调用valueOf()方法，但是数字的此方法是简单继承而来，并没有重写（当然这个重写不是我们实现），返回值是数组对象本身，并不是一个值类型，所以就转而调用toString()方法，于是就实现了转换为字符串的目的。

#### 说明

大多数对象隐式转换为值类型都是首先尝试调用valueOf()方法。但是Date对象是个例外，此对象的valueOf()和toString()方法都经过精心重写，默认是调用toString()方法，比如使用+运算符，如果在其他算数运算环境中，则会转而调用valueOf()方法。

```
let date = new Date();
console.log(date + "1"); //Sun Apr 17 2014 17:54:48 GMT+0800 (CST)1
console.log(date + 1);//Sun Apr 17 2014 17:54:48 GMT+0800 (CST)1
console.log(date - 1);//1460886888556
console.log(date * 1);//1460886888557
复制代码
```

举例巩固提高 下面我们一起来做做下面的题目吧！

```
let a;
console.dir(0 == false);//true
console.dir(1 == true);//true
console.dir(2 == {valueOf: function(){return 2}});//true

console.dir(a == NaN);//false
console.dir(NaN == NaN);//false

console.dir(8 == undefined);//false
console.dir(1 == undefined);//false
console.dir(2 == {toString: function(){return 2}});//true

console.dir(undefined == null);//true

console.dir(null == 1);//false

console.dir({ toString:function(){ return 1 } , valueOf:function(){ return [] }} == 1);//true

console.dir(1=="1");//true
console.dir(1==="1");//false

[] == 0 // true
复制代码
```

上面的都可以理解了吗？最后一行代码结果是true的原因是什么？

### es6

这部分考查对es6的掌握熟练度，新增的一些类型，语法，等等。推荐大家看一看[阮一峰老师的es6的文章](https://link.juejin.cn?target=https%3A%2F%2Fes6.ruanyifeng.com%2F)

### 手写实现

#### js实现bind

```
// 实现bind
Function.prototype.myBind = function (context,...args) {
    let self = this;
    let params = args;
    return function (...newArgs) {
        self.call(context, ...params.concat(...newArgs))
    }
}
var a = {
    name: 'this is a'
}

function sayName() {
    console.log(this.name, arguments)
}

let newfn = sayName.myBind(a, '1234', '5678')
newfn('1000', '2000')
复制代码
```

#### js实现call

```
// 实现call
Function.prototype.myCall = function (context,...args) {
    context.fn = this;
    context.fn(...args)
    delete context.fn;
}
var a = {
    name: 'this is a'
}
function sayName() {
    console.log(this.name, arguments)
}
sayName.myCall(a, '1234', '5678')
复制代码
```

#### js实现setInterval

```
// setTimeout 实现setInterval
function mySetInterval(fn, time) {
    let timer = {};
    function timeout() {
        timer.t = setTimeout(() => {
            fn();
            timeout()
        }, time)
    }
    timeout();
    return timer;
}


function clearMyInterval(timer) {
    clearTimeout(timer.t)
}
复制代码
```

#### promise

promise考察点比较多，包括实现自己的promise和一些调用的知识点

推荐两篇文章：[实现Promise](https://juejin.cn/post/6901658026794483725)和[Promise题](https://juejin.cn/post/6870745273971245064)

## css

- 盒模型，盒模型的margin、padding有什么特点？
- flex布局的属性都有什么，都代表什么含义？
- 左右居中布局、上下居中布局、上下左右居中布局，实现方式是什么？
- 单行超出省略...，多行超出省略...
- 自适应布局
- 响应式布局
- less、scss、stylus
- rem、em、vw等
- 移动端1px如何实现？
- css如何实现三角形？
- css的link和import区别是什么？

## html

- meta用来干嘛的
- 块元素、行元素区别和举例
- html5新增的标签有哪些？
- video标签的使用，事件等

# 前端框架

## vue

### vue基本

一、 vue的生命周期： beforeCreate、created、beforeMounte、mounted、beforeUpdate、updated、beforeDestory、destroyed；

二、 Vue组件通信：

- props(emit)；
- $attr和$listeners，
- 事件bus对象(bus.$on, bus.$emit)，
- provide(inject)，
- v-model(props:value, emit:input )，
- $children，
- vuex

三、keep-alive使用及原理，LRU算法

四、vue的v-show和v-if的区别；vue的watch和computed的区别；

五、其他：vue的服务端渲染，例如框架nuxt的使用；前端组件库的使用，如element-ui；

### vue2与vue3

3是Proxy+Reflect，2是Object.defineProperty；dom-diff的优化；componentApi等

### vue-router

- 实现的模式：hash & history；两者的区别和分析
- 事件：全局：beforeEach、afterEach；路由：beforeEnter；组件内：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
- 实现原理，源码

### vuex

- vuex是什么？[vuex官网](https://link.juejin.cn?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F)
- state、getters、mutations(commit)、actions(dispatch)、module
- mapState、mapMutations、mapGetters、mapActions；subscribe，subscribeAction
- 实现原理，源码等

## react

一、生命周期

```
  1.react16之前的生命周期是什么？
  2.react16之后的生命周期是什么？
  3.react16和react16之前的版本有什么区别？
  4.requestAnimationFrame是什么？requestIdleCallback是什么？如何实现requestAnimationFrame
复制代码
// 实现requestAnimationFrame
var lastTime = 0
window.requestAnimationFrame = function (callback) {
    let now = Date().now;
    let timeCall = Math.max(0, 16 - (lastTime - now));

    let id = setTimeout(function () {
        callback(now + timeCall)
    }, timeCall)
    
    lastTime = now + timeCall;
    return id;
}
复制代码
```

二、react-hooks

```
1.常用的reacthooks都有哪些？
2.使用useEffect模拟componentDidMount和componentDidUpdate
3.useEffect返回的是什么？做什么用的？
4.useEffect和useLayoutEffect的区别是什么？
5、useMemo和useCallback是什么？做什么用的？有什么区别？
复制代码
```

三、react-router

```
1.如何实现路由切换，有几种方式？
2.有哪几个钩子函数？onEnter和routerWillLeave
3.link与a标签的区别什么？
复制代码
```

四、redux

```
1.redux是什么？做什么的？与vuex有什么区别？
2.redux包含哪几块？state，reducers，actions
复制代码
```

五、其他：

```
1.服务端渲染next；
2.组件库antd；
3.PureComponent与Component的区别是什么？
4.react的性能优化有什么建议？
5.封装一个promise的setState
复制代码
// 使用promise封装setState
function setStateP(state) {
    return new Promise(resolve => {
        this.setState(state, resolve)
    })
}
复制代码
```

## 工具型-webpack

- 1.webpack是什么？
- 2.webpack的工作原理是什么？
- 3.写过plugin吗？怎么实现的？
- 4.loader是做什么的？loader和plugin的区别什么？
- 5.关于webpack的优化建议等

[聊聊webpack](https://juejin.cn/post/6904829145188925447)

# nodeJs

- event-loop：可以看下这篇文章[nodejs的event loop](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdeedcbf68880)

- egg：声明周期，目录结构，常用插件

- koa：Koa的中间件与express的中间件的区别，实现一个洋葱圈模型的函数

  ```
  // 洋葱圈模型
  function compose(middleware) {
      return function (context, next) {
          let index = -1;
          function dispatch(i) {
              if (i <= index) {
                  return Promise.reject('err')
              }
              index = i;
              let fn = middleware[i];
              if(i === middleware.length) {
                  fn = next;
              }
              if (!fn) {
                  return Promise.resolve();
              }
              try {
                  return Promise.resolve(fn(context, function next() {
                      return dispatch(i + 1);
                  }))
              } catch (e) {
                  return Promise.reject(e);
              }
          }
          dispatch(0);
      }
  }
  复制代码
  ```

## child_process

- 1. spawn、exec、execFile、fork、
- 1. fork与spawn类似，不同在于fork创建子进程需要执行js文件；
- 1. spawn与exec和execFile不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦进程超时就会被杀死；
- 1. exec与execFile不同的是，exec执行的是已有命令，execFile执行的是文件。

## pm2

- pm2常用命令：start、stop、delete、logs、restart、list
- -i 参数，启动多线程；watch，-w，监听文件改变
- pm2配置文件，可以配置多个app，apps数组，启动 pm2 start pm2.connfig.js —only=one-app-name

# 计算机基础

## http系列

- 三次握手是什么？为什么需要三次？
- 四次挥手是什么？为何需要四次？
- http1、http2、https的区别是什么？
- https是如何进行加密的？
- 请求如何取消？AbortController

## 排序

- 冒泡排序

```
// 从小到大排序：
function bubblingSort(list){
     let temp;
     for(let i=0; i<list.length; i++){
          for(let j=i; j<list.length; j++){
               if(list[i] > list[j]){
                    temp = list[i];
                    list[i] = list[j];
                    list[j] = temp;
               }
          }
     }
     return list;
}
let res = bubblingSort([10, 8, 2, 23, 30, 4, 7, 1])
console.log(res); // [1, 2, 4, 7, 8, 10, 23, 30]
复制代码
```

- 直接选择排序

```
从小到大排序：
function selectSort(list){
     let r,temp;
     for(let j=0; j<list.length; j++){
          for(let i = j+1; i<list.length; i++){
               if(list[j] > list[i]){
                   temp = list[j];
                   list[j] = list[i];
                   list[i] = temp;
               }
          }
     }
     return list;
}
let res = selectSort([10, 8, 2, 23, 30, 4, 7, 1])
console.log(res); // [1, 2, 4, 7, 8, 10, 23, 30]
复制代码
```

- 直接插入排序

整个排序过程为n-1趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。

```
function insertSort(list) {
    let flag;
    for(let index = 1; index < list.length; index++) {
        flag = list[index];
        let j = index - 1;
        while (flag < list[j]) {
            list[j + 1] = list[j]
            j--;
        }
        list[j + 1] = flag;
    }
     return list;
}
let res = insertSort([10, 8, 2, 23, 30, 4, 7, 1])
console.log(res); // [1, 2, 4, 7, 8, 10, 23, 30]
复制代码
```

- 希尔排序

排序过程：先取一个正整数d1<n，把所有相隔d1的记录放一组，组内进行直接插入排序；然后取d2<d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止

```
function shellSort(list) {
    const length = list.length;
    let j, temp;
    for (let d = parseInt(length / 2); d >= 1; d = parseInt(d / 2)) {
        for (let i = d; i < length; i++) {
            temp = list[i];
            j = i - d;
            while (j >= 0 && temp < list[j]) {
                list[j + d] = list[j];
                j -= d;
            }
            list[j + d] = temp;
        }
    }
    return list;
}
let res = shellSort([10, 8, 2, 23, 30, 4, 7, 1])
console.log(res); // [1, 2, 4, 7, 8, 10, 23, 30]

复制代码
```

- 快速排序

通过一次排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可对这两部分记录进行排序，以达到整个序列有序。

```
function quickSort(v,left,right){
    if(left < right){
        var key = v[left];
        var low = left;
        var high = right;
        while(low < high){
            while(low < high && v[high] > key){
                high--;
            }
            v[low] = v[high];
            while(low < high && v[low] < key){
                low++;
            }
            v[high] = v[low];
        }
        v[low] = key;
        quickSort(v,left,low-1);
        quickSort(v,low+1,right);
    }
}
let list = [10, 8, 2, 23, 30, 4, 7, 1]
quickSort(list, 0, 7)
console.log(list); // [1, 2, 4, 7, 8, 10, 23, 30]
复制代码
```

## 其他

- tcp/ip协议的五层模型：应用层、传输层、网络层、数据链路层、物理层
- 算法相关，leetcode上面刷吧
- 二叉树等的遍历，前中后序遍历，深度优先，广度优先；
- 栈、队列的使用
- 链表的使用

# 其他

- hybird

```
1、什么是hybrid？
2、jsbridge是什么？如何实现？
3、hybrid开发需要注意什么？
复制代码
```

- 预加载和懒加载：

```
1.包括图片视频等内容的懒加载(IntersectionObserver的使用封装)
2.数据的预加载，纯h5的prefetch && 与端结合的预加载方案
3.js的按需加载(配合webpack的import().then()的split实现)
复制代码
```

- dom文档的加载步骤是什么？

```
1、 解析HTML结构。
2、 加载外部脚本和样式表文件。
3、 解析并执行脚本代码。
4、 构造HTML DOM模型。//ready
5、 加载图片等外部文件。
6、 页面加载完毕。//load
复制代码
```

- 从浏览器输入url，到展现完成，经过了什么？

```
此问题网上有很多回答，属于自由发挥问题；回答的深度和广度能够看出本人的知识面。此处就不多说了。
复制代码
```

- 前端性能优化等方方面面

# 

